<html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Record Row Type and Row Polymorphism (2018-11-18)</title><link rel="stylesheet" href="/assets/main.min.css"/><link rel="stylesheet" href="https://maxcdn.icons8.com/fonts/line-awesome/1.1/css/line-awesome-font-awesome.min.css"/></head><meta name="description" content="Record, or object in another programming languages, is usually defined as a list of product  pairs. The most common syntax to access record&#39;s properties is dot "/><body><header><div class="container grid-lg"><nav class="horizontal main-nav"><ul><li><a href="/">Home</a></li><li><a href="/works.html">Works</a></li><li><a href="/posts">Posts</a></li><li><a href="/about.html">About</a></li><li><a href="https://www.visualcv.com/toan-nguyen">CV</a></li></ul></nav></div></header><section class="section"><div id="main"><div class="wrapper"><div class="container grid-lg"><hr class="mt-2"/><article class="article"><h1 id="Record_Row_Types_an_Row_Polymorphism">Record, Row Types an Row Polymorphism</h1><p>Record, or object in another programming languages, is usually defined as a list of product <code>name =&gt; value</code> pairs. The most common syntax to access record&#39;s properties is dot <code>.</code></p><pre class="code" data-lang="javascript"><code>const obj = { x: 1, y: 2 }<br/><br/>console.log(obj.x) &#x2F;&#x2F; 1</code></pre><p>In Scala, we use <code>class</code> or <code>case class</code>, because object is singleton
In Haskell, there is no &quot;record type&quot;, it is only the syntactic sugar to a constructor type with functions that access it&#39;s fields</p><pre class="code" data-lang="purescript"><code>data Person = Person { name :: String, age :: Int }<br/><br/>-- syntactic sugar to<br/>data Person = Person String Int <br/><br/>name :: Person :: String <br/>name (Person name _) = name<br/><br/>age :: Person :: Int <br/>age (Person _ age) = age<br/><br/>-- so, you can create a record in both ways<br/>person :: Person <br/>person = Person { name = &quot;Mike&quot;, age = 1 }<br/>-- or <br/>person = Person &quot;Mike&quot; 1</code></pre><p>Therefore, the most common issue in Haskell is namespacing for record field names. That means you can&#39;t define <code>Person { name :: String }</code> and <code>Cat { name :: String }</code> in same module. Function <code>name</code> will be duplicated. Moreover, Record in Haskell isn&#39;t extensible and polymorphism</p><p>PureScript is inspired of Haskell, however Record mechanism is different. It&#39;s constructor takes a row of concrete types. Same as JavaScript, we use dot to access properties.</p><pre class="code" data-lang="purescript"><code>data Record :: # Type -&gt; Type<br/><br/>type Person = Record (name :: String, age :: Number)<br/>-- or syntactic sugar with curly braces  <br/>type Person = { name :: String, age :: Number }<br/><br/>person :: Person <br/>person = { name: &quot;Mike&quot;, age: 1 }<br/><br/>log person.name</code></pre><p>The fun here is Row Types, which make Record more flexible and overcome the issue of Haskell</p><h2 id="Row_Types_and_Row_Polymorphism">Row Types and Row Polymorphism</h2><p>Row Types is well explained in PureScript <a href="https://github.com/purescript/documentation/blob/master/language/Types.md">documentation</a>:</p><blockquote><p>A row of types represents an unordered collection of named types, with duplicates. Duplicate labels have their types collected together in order, as if in a NonEmptyList. This means that, conceptually, a row can be thought of as a type-level Map Label (NonEmptyList Type).
Rows are not of kind Type: they have kind # k for some kind k, and so rows cannot exist as a value. Rather, rows can be used in type signatures to define record types or other type where labelled, unordered types are useful.</p></blockquote><p>Therefore, Row Types can be extensible and polymorphism. It is denoted similar to Record, replaced with closed brackets. To denote an open row, separate the specified terms from a row variable by a pipe. It defines arguments for Record&#39;s constructor</p><pre class="code" data-lang="purescript"><code>-- closed row<br/>type ClosedPersonRow = ( name :: String, age :: Number )<br/>-- opened row<br/>type OpenedPersonRow r = ( name :: String, age :: Number | r )<br/><br/>type Person r = Record (OpenedPersonRow r)</code></pre><p>You have noticed polymorphic variable <code>r</code>, right? In other words, Person accepts any record which has properties name and age, and any other record properties. </p><pre class="code" data-lang="purescript"><code>type Pet = Record { species :: String | Person }<br/><br/>introduce :: { name :: String, age :: String | r } -&gt; String <br/>introduce { name, age } = name &lt;&gt; &quot;, &quot; &lt;&gt; show age &lt;&gt; &quot; years old&quot;<br/><br/>introduce { name: &quot;Doraemon&quot;, age: 3, species: &quot;dog&quot; }<br/>-- Doraemon, 3 years old<br/><br/>introduce { name: &quot;Doraemon&quot; }<br/>-- Error: Type of expression lacks required label age.<br/></code></pre><p>However, the last one can&#39;t be compiled, because property <code>age</code> is missing.</p><p>It doesn&#39;t stop here. The real fun of Row Types is Type-Level Programming, which is introduced in the next section </p><h2 id="PrimRow_">Prim.Row </h2><p>PureScript compiler also provides automatically solved type classes for working with row types. They help the code type-safe, generic, reduce duplicated codes, yet take advantage of compiler&#39;s power. You can read the documentation at <a href="https://pursuit.purescript.org/builtins/docs/Prim.Row">Pursuit</a>. However, you will be easier to grasp with simple examples.</p><p><a href="https://github.com/purescript/purescript-record">purescript-record</a> includes functions for working with records and polymorphic labels. Under the hood, these functions use Foreign Function Inteface (FFI) from JavaScript object, and Row Constraints.</p><p><code>union</code> function implement <code>Union</code> class. It returns record <code>r3</code> including properties of both records <code>r1</code>, <code>r2</code>.</p><pre class="code" data-lang="purescript"><code>class Union (left :: # Type) (right :: # Type) (union :: # Type) <br/>  | left right -&gt; union, right union -&gt; left, union left -&gt; right<br/><br/>union :: forall r1 r2 r3. Union r1 r2 r3 =&gt; { | r1 } -&gt; { | r2 } -&gt; { | r3 }<br/><br/>union { x: 1, y: &quot;y&quot; } { y: 2, z: true }<br/> :: { x :: Int, y :: String, y :: Int, z :: Boolean }</code></pre><p>In record, labels can duplicated. To keep labels unique, use <code>nub</code>, implement of <code>Nub</code> constraint</p><pre class="code" data-lang="purescript"><code>class Nub (original :: # Type) (nubbed :: # Type) | original -&gt; nubbed<br/><br/>nub :: forall r1 r2. Nub r1 r2 =&gt; { | r1 } -&gt; { | r2 }<br/><br/>nub $ union { x: 1, y: &quot;y&quot; } { y: 2, z: true }<br/>-- { x: 1, y: &quot;y&quot;, z: true }</code></pre><p><strong>Note</strong>: </p><ul><li>Nub is left hand priority. <code>y :: String</code> will be kept instead of right <code>y :: Int</code>. You have to think oposite if you come from JavaScript land.</li><li><code>nub</code> is used for polymorphism records. In theory, record labels can be duplicated, but not in compiler. That means if you type <code>{ x: 1, y: &quot;y&quot;, y: 2, z: true }</code>, it can&#39;t compile. </li></ul><p><code>merge</code> is the combination of <code>Union</code> and <code>Nub</code>:</p><pre class="code" data-lang="purescript"><code>merge :: forall r1 r2 r3 r4. Union r1 r2 r3 =&gt; Nub r3 r4 =&gt; { | r1 } -&gt; { | r2 } -&gt; { | r4 }<br/><br/>merge { x: 1, y: &quot;y&quot; } { y: 2, z: true }<br/>-- { x: 1, y: &quot;y&quot;, z: true }</code></pre><p><code>class Cons</code> constraint helps the compiler know that, there is a property with label <code>l</code>. It is useful if you want to access a property in any record without know its constructor. <code>get</code> and <code>set</code> functions are most common use case of <code>Cons</code></p><pre class="code" data-lang="purescript"><code><br/>class Cons (label :: Symbol) (a :: Type) (tail :: # Type) (row :: # Type) <br/>  | label a tail -&gt; row, label row -&gt; a tail<br/><br/>get :: forall r r&#39; l a<br/>  . IsSymbol l <br/>  =&gt; Cons l a r&#39; r <br/>  =&gt; SProxy l <br/>  -&gt; { | r } <br/>  -&gt; a<br/><br/>get (SProxy :: SProxy &quot;x&quot;) { x: 1, y: &quot;y&quot;, z: true }<br/>-- 1<br/><br/>set :: forall r1 r2 r l a b<br/>  . IsSymbol l <br/>  =&gt; Cons l a r r1 <br/>  =&gt; Cons l b r r2 <br/>  =&gt; SProxy l <br/>  -&gt; b <br/>  -&gt; { | r1 } <br/>  -&gt; { | r2 }<br/><br/><br/>set (SProxy :: SProxy &quot;x&quot;) &quot;x&quot; { x: 1, y: &quot;y&quot;, z: true }<br/>-- { x: &quot;x&quot;, y: &quot;y&quot;, z: true }</code></pre><p><code>class Lacks</code> is the opposite of <code>Cons</code>, a given Symbol label not existing in row. You may think of <code>insert</code> and <code>delete</code> functions that add&#x2F;remove a property with label <code>l</code> from input record</p><pre class="code" data-lang="purescript"><code>class Lacks (label :: Symbol) (row :: # Type) <br/><br/>insert :: forall r1 r2 l a<br/>  . IsSymbol l <br/>  =&gt; Lacks l r1 <br/>  =&gt; Cons l a r1 r2 <br/>  =&gt; SProxy l -&gt; a -&gt; { | r1 } -&gt; { | r2 }<br/><br/>insert (SProxy :: SProxy &quot;x&quot;) &quot;x&quot; { y: &quot;y&quot;, z: true }<br/>-- { x: &quot;x&quot;, y: &quot;y&quot;, z: true }<br/><br/>delete :: forall r1 r2 l a<br/>  . IsSymbol l <br/>  =&gt; Lacks l r1 <br/>  =&gt; Cons l a r1 r2 <br/>  =&gt; SProxy l -&gt; { | r2 } -&gt; { | r1 }<br/><br/>delete (SProxy :: SProxy &quot;x&quot;) { x: &quot;x&quot;, y: &quot;y&quot;, z: true }<br/>-- { y: &quot;y&quot;, z: true }</code></pre><p>You may have an idea &quot;We can insert and delete without Lacks constraint&quot;. Yes, in theory we can. However, label can be duplicated. Inserting same property many times can cause unexpected results. <code>Lacks</code> constraint keep label unique.</p><h2 id="When_to_use_Row_Constraints">When to use Row Constraints?</h2><p>Unless you are developing libraries, or generics and type-level programming, you don&#39;t need them. Row polymorphism and <a href="https://github.com/purescript/purescript-record">purescript-record</a> library is good enough for daily use. However, if you need to write FFI and reuse existed JavaScript library, row types is very useful. The most common use is optional record. </p><p>For example, <a href="https://github.com/lumihq/purescript-react-basic/blob/master/src/React/Basic/DOM/Internal.purs">default React components&#39;s props record</a> are many optional attributes. You don&#39;t really need to construct all fields.</p><pre class="code" data-lang="purescript"><code>type SharedProps specific =<br/>  -- | `key` is not really a DOM attribute - React intercepts it<br/>  ( key               :: String<br/><br/>  , about             :: String<br/>  , acceptCharset     :: String<br/>  , accessKey         :: String<br/>  , allowFullScreen   :: Boolean<br/>  ...<br/>  | specific<br/>  )</code></pre><p>However, if you make Props as parameter to create JSX element. You must fill all label values. It is really boring and useless.</p><pre class="code" data-lang="purescript"><code>p :: Record SharedProps_p -&gt; JSX <br/><br/>p { key: &quot;&quot;, about: &quot;&quot;, acceptCharset: &quot;&quot;, accessKey: &quot;&quot;, ... } -- uhh, too long</code></pre><p>Before PureScript support row types, the popular idea is using Array Props to define React properties (Haskel DOM libraries is the same idea). It is still good. The flaw is attributes can be duplicated.</p><p>Since Row Constraints appearance, the issue has easily been solved.</p><pre class="code" data-lang="purescript"><code>p<br/>  :: forall attrs attrs_<br/>   . Union attrs attrs_ (SharedProps Props_p)<br/>  =&gt; Record attrs<br/>-&gt; JSX<br/><br/>p { className: &quot;text-center&quot; } []</code></pre><p><a href="https://github.com/lumihq/purescript-react-basic">purescript-react-basic</a> takes advantage of row types to make React simple, type-safe and more.</p><p>One common case is default values. In JavaScript, you will do it with:</p><pre class="code" data-lang="javascript"><code>const defaultValues = { x: 0, y: &quot;&quot; }<br/><br/>const result = (input) =&gt; Object.assign(defaultValues, input);</code></pre><p>In PureScript, the code will be </p><pre class="code" data-lang="purescript"><code><br/>type ObjectRow r = ( x :: Int, y :: String )<br/>type OpenRow r = ( x :: Int, y :: String | r )<br/><br/>result :: <br/>  forall r1 r2<br/>  . Union r1 ObjectRow (OpenRow r2)<br/>  =&gt; Nub (OpenRow r2) ObjectRow<br/>  =&gt; Record r1 -&gt; Record OpenRow<br/>result r1 = merge r1 { x: 0, y: &quot;&quot; }</code></pre><p>However, most of time we don&#39;t need to do with row types, if input directly</p><pre class="code" data-lang="purescript"><code>f :: Record OpenRow -&gt; String<br/><br/>f (merge { x: 1 } defaultValues)<br/>-- or <br/>f defaultValues { x = 1 }</code></pre><h2 id="Does_Haskell_support_Row_Types">Does Haskell support Row Types?</h2><p>Yes. There is library <a href="http://hackage.haskell.org/package/row-types">row-types</a>. It is self-explain, right? However, there are another extensions that works with Record too. Row Types are better in PureScript because it is easy to do with FFI and JavaScript Object. The critical point is performance and complexity. We can&#39;t say which one is the best</p><h2 id="Conclusion">Conclusion</h2><p>Because PureScript is a transpiler, working with FFI is unavoidable. Row Types help us to work with records easily in polymorphic way, Row Types are not only method to work with Record. <a href="">purescript-variant</a> provide similar functions. However, there are more fun things to do with Row family. <code>RowList</code> is the cool feature that support generic methodogy to have fun with record. <a href="https://twitter.com/jusrin00">Justin Woo</a> - a brilliant PureScript contributor - published a list of tutorials and talks about this topic. You can read his essays <a href="https://github.com/justinwoo/awesome-rowlist">here</a></p></article></div></div></div></section><footer><div class="wrapper"><div class="container grid-lg"><hr/><div class="text-center"><a class="secondary" href="https://github.com/hgiasac"><i class="fa fa-github fa-2x"> </i></a><a class="secondary" href="https://www.linkedin.com/in/toan-nguyen-83295527/"><i class="fa fa-linkedin fa-2x"> </i></a><a class="secondary" href="https://stackoverflow.com/users/4230985/hgiasac"><i class="fa fa-stack-overflow fa-2x"> </i></a></div><div class="text-center mt-2">© Toan Nguyen 2017-2018</div></div></div></footer></body></html>