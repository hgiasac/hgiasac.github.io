<html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Record Row Type and Row Polymorphism (2018-11-18)</title><link rel="stylesheet" href="/assets/main.min.css"/><link rel="stylesheet" href="https://maxcdn.icons8.com/fonts/line-awesome/1.1/css/line-awesome-font-awesome.min.css"/></head><meta name="description" content="Record, or object in another programming languages, is usually defined as a list of product  pairs. The most common syntax to access record&#39;s properties is dot "/><body><header><div class="container grid-lg"><nav class="horizontal main-nav"><ul><li><a href="/">Home</a></li><li><a href="/works.html">Works</a></li><li><a href="/posts">Posts</a></li><li><a href="/about.html">About</a></li><li><a href="https://www.visualcv.com/toan-nguyen">CV</a></li></ul></nav></div></header><section class="section"><div id="main"><div class="wrapper"><div class="container grid-lg"><hr class="mt-2"/><article class="article"><h1 id="Record_Row_Types_an_Row_Polymorphism">Record, Row Types an Row Polymorphism</h1><p>Record, or object in another programming languages, is usually defined as a list of product <code>name =&gt; value</code> pairs. The most common syntax to access record&#39;s properties is dot <code>.</code></p><pre class="code" data-lang="javascript"><code>const obj = { x: 1, y: 2 }<br/><br/>console.log(obj.x) &#x2F;&#x2F; 1</code></pre><p>In Scala, we use <code>class</code> or <code>case class</code>, because object is singleton
In Haskell, there is no &quot;record type&quot;, it is only the syntactic sugar to a constructor type with functions that access it&#39;s fields</p><pre class="code" data-lang="haskell"><code>data Person = Person { name :: String, age :: Int }<br/><br/>-- syntactic sugar to<br/>data Person = Person String Int <br/><br/>name :: Person :: String <br/>name (Person name _) = name<br/><br/>age :: Person :: Int <br/>age (Person _ age) = age<br/><br/>-- so, you can create a record in both ways<br/>person :: Person <br/>person = Person { name = &quot;Mike&quot;, age = 1 }<br/>-- or <br/>person = Person &quot;Mike&quot; 1</code></pre><p>Therefore, the most common issue in Haskell is namespacing for record field names. That means you can&#39;t define <code>Person { name :: String }</code> and <code>Cat { name :: String }</code> in same module. Function <code>name</code> will be duplicated. Moreover, Record in Haskell isn&#39;t extensible and polymorphism</p><p>PureScript is inspired of Haskell, however Record mechanism is different. It&#39;s constructor takes a row of concrete types. Same as JavaScript, we use dot to access properties.</p><pre class="code" data-lang="haskell"><code>data Record :: # Type -&gt; Type<br/><br/>type Person = Record (name :: String, age :: Number)<br/>-- or syntactic sugar with curly braces  <br/>type Person = { name :: String, age :: Number }<br/><br/>person :: Person <br/>person = { name: &quot;Mike&quot;, age: 1 }<br/><br/>log person.name</code></pre><p>The fun here is Row Types, which make Record more flexible and overcome the issue of Haskell</p><h2 id="Row_Types_and_Row_Polymorphism">Row Types and Row Polymorphism</h2><p>Row Types is well explained in PureScript <a href="https://github.com/purescript/documentation/blob/master/language/Types.md">documentation</a>:</p><blockquote><p>A row of types represents an unordered collection of named types, with duplicates. Duplicate labels have their types collected together in order, as if in a NonEmptyList. This means that, conceptually, a row can be thought of as a type-level Map Label (NonEmptyList Type).
Rows are not of kind Type: they have kind # k for some kind k, and so rows cannot exist as a value. Rather, rows can be used in type signatures to define record types or other type where labelled, unordered types are useful.</p></blockquote><p>Therefore, Row Types can be extensible and polymorphism. It is denoted similar to Record, replaced with closed brackets. To denote an open row, separate the specified terms from a row variable by a pipe. It defines arguments for Record&#39;s constructor</p><pre class="code" data-lang="haskell"><code>-- closed row<br/>type ClosedPersonRow = ( name :: String, age :: Number )<br/>-- opened row<br/>type OpenedPersonRow r = ( name :: String, age :: Number | r )<br/><br/>type Person r = Record (OpenedPersonRow r)</code></pre><p>You have noticed polymorphic variable <code>r</code>, right? In other words, Person accepts any record which has properties name and age, and any other record properties. </p><pre class="code" data-lang="haskell"><code>type Pet = Record { species :: String | Person }<br/><br/>introduce :: { name :: String, age :: String | r } -&gt; String <br/>introduce { name, age } = name &lt;&gt; &quot;, &quot; &lt;&gt; show age &lt;&gt; &quot; years old&quot;<br/><br/>introduce { name: &quot;Doraemon&quot;, age: 3, species: &quot;dog&quot; }<br/>-- Doraemon, 3 years old<br/><br/>introduce { name: &quot;Doraemon&quot; }<br/>-- Error: Type of expression lacks required label age.<br/></code></pre><p>However, the last one can&#39;t be compiled, because property <code>age</code> is missing.</p><p>It doesn&#39;t stop here. The real fun of Row Types is Type-Level Programming, which is introduced in the next section </p></article></div></div></div></section><footer><div class="wrapper"><div class="container grid-lg"><hr/><div class="text-center"><a class="secondary" href="https://github.com/hgiasac"><i class="fa fa-github fa-2x"> </i></a><a class="secondary" href="https://www.linkedin.com/in/toan-nguyen-83295527/"><i class="fa fa-linkedin fa-2x"> </i></a><a class="secondary" href="https://stackoverflow.com/users/4230985/hgiasac"><i class="fa fa-stack-overflow fa-2x"> </i></a></div><div class="text-center mt-2">Â© Toan Nguyen 2017-2018</div></div></div></footer></body></html>