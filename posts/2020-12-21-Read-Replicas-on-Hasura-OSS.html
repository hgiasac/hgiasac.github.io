<html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Read-Replicas-on-Hasura-OSS (2020-12-21)</title><meta property="og:title" content="Read-Replicas-on-Hasura-OSS (2020-12-21)"/><meta property="twitter:title" content="Read-Replicas-on-Hasura-OSS (2020-12-21)"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,500"/><link rel="stylesheet" href="/assets/main.min.css"/><link rel="stylesheet" href="https://maxcdn.icons8.com/fonts/line-awesome/1.1/css/line-awesome-font-awesome.min.css"/></head><meta name="description" content="The most important challenges on production are performance and high availability. Database service is the Single Point of Failure of backend services. Hasura GraphQL Engine isn&#39;t different."/><meta property="og:description" content="The most important challenges on production are performance and high availability. Database service is the Single Point of Failure of backend services. Hasura GraphQL Engine isn&#39;t different."/><meta property="twitter:description" content="The most important challenges on production are performance and high availability. Database service is the Single Point of Failure of backend services. Hasura GraphQL Engine isn&#39;t different."/><body><header><div class="container grid-lg"><nav class="horizontal main-nav"><ul><li><a href="/">Home</a></li><li><a href="/posts">Posts</a></li><li><a href="/about.html">About</a></li><li><a href="https://www.visualcv.com/toan-nguyen">CV</a></li></ul></nav></div></header><section class="section"><div id="main"><div class="wrapper"><div class="container grid-lg"><hr class="mt-2"/><article class="article"><h1 id="Read_Replicas_on_Hasura_OSS">Read Replicas on Hasura OSS</h1><p>The most important challenges on production are performance and high availability. Database service is the Single Point of Failure of backend services. Hasura GraphQL Engine isn&#39;t different.</p><p>High availability can be solved by database replication solutions. Otherwise, performance can be improved by load balancing read requests with read replicas. However, this problem requires the support of application.</p><p>As you probably know, Read Replicas feature are exclusively supported on <a href="https://hasura.io/docs/1.0/graphql/cloud/read-replicas.html">Hasura Pro and Cloud versions</a>. However, you still can setup read replicas on OSS version.</p><h2 id="Read-only_mode">Read-only mode</h2><p>Recently, Hasura team releases an experiment <a href="https://hub.docker.com/layers/hasura/graphql-engine/v1.3.2-readonly/images/sha256-3736a4bf38276dad86c44d27fb223f614ba5129768e52c1e48746f3cd0ddab9f?context=explore">read-only GraphQL Engine image</a> that can run on read replica server. </p><p>Thank for that, the idea becomes simple. We just deploy 2 GraphQL Engine groups:</p><ul><li>Primary: connect to Primary database server.</li><li>Read-only: connect to Read replica servers.</li></ul><p><img src="/assets/oss-read-replicas.png" alt="OSS read replicas"/></p><p>Client applications do routing GraphQL requests to 2 endpoints:</p><ul><li>mutation: requests to primary endpoint.</li><li>query &amp; subscription: requests to read-only endpoint.</li></ul><h2 id="Caveat">Caveat</h2><ul><li>Metadata is loaded once on startup. New metadata changes aren&#39;t reloaded on read-only instance. Therefore you have to restart the container to refresh metadata.</li><li>Need more works on client applications.</li><li>Most of functions on Hasura console is unusable. However it isn&#39;t problem. We can use the primary console instead.</li></ul><h2 id="Implementation">Implementation</h2><p>You can download and run the demo <a href="https://github.com/hgiasac/hasura-oss-read-replicas-demo">here</a></p><p>The demo simulates above diagram, using <code>docker-compose</code>:</p><ul><li>app: React webapp demo.</li><li>postgres-master: Postgres master server.</li><li>postgres-replica: Postgres replica server.</li><li>data: GraphQL Engine primary instance that connects to <code>postgres-master</code>.</li><li>data-readonly: Read-only GraphQL Engine instance that connects to <code>postgres-replica</code>.</li></ul><p>*Note: Metadata on read-only instance can&#39;t be reloaded. So you have to restart this service on first time startup, after primary Hasura applied migrations and metadata successfully.*</p><h2 id="Client_Application">Client Application</h2><p>Because read-only service is on different endpoint, you need to do routing on client side&#39;s GraphQL client.</p><p>The idea is simple. You just construct 2 GraphQL clients, one for mutation and one for query&#x2F;subscription.</p><p>If you are using React, you may concern that it is annoyed to use 2 GraphQL clients using React hook and provider. Don&#39;t worry, Apollo client is easy customizable and composible with <code>split</code>:</p><pre class="code" data-lang="ts"><code>const mutationLink = new HttpLink({<br/>  uri: &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;v1&#x2F;graphql&#39;,<br/>});<br/><br/>const queryLink = new HttpLink({<br/>  uri: &#39;http:&#x2F;&#x2F;localhost:8081&#x2F;v1&#x2F;graphql&#39;,<br/>});<br/><br/>const subscriptionLink = new WebSocketLink({<br/>  uri: &#39;ws:&#x2F;&#x2F;localhost:8081&#x2F;v1&#x2F;graphql&#39;,<br/>});<br/>  <br/>const link = split(<br/>  ({ query }) =&gt; {<br/>    const { kind, operation } = getMainDefinition(query) as OperationDefinitionNode;<br/><br/>    return kind === &#39;OperationDefinition&#39; &amp;&amp; operation === &#39;subscription&#39;;<br/>  },<br/>  subscriptionLink,<br/>  split(<br/>    ({ query }) =&gt; {<br/>      const { kind, operation } = getMainDefinition(query) as OperationDefinitionNode;<br/><br/>      return kind === &#39;OperationDefinition&#39; &amp;&amp; operation === &#39;mutation&#39;;<br/>    },<br/>    mutationLink,<br/>    queryLink<br/>  )<br/>);</code></pre><p>You can explore React demo by opening http:&#x2F;&#x2F;localhost:3000 from above demo. </p><h2 id="Conclusion">Conclusion</h2><p>Although there are several caveats, this solution can help you improving basic performance issues. I still recommend using Hasura Cloud&#x2F;Pro for easy Read Replicas and advanced Caching.</p><p>However, there isn&#39;t silver bullet for all issues. Read-only GraphQL Engine is also a cool feature that provides you new ideas for advanced system design.</p></article></div></div></div></section><footer><div class="wrapper"><div class="container grid-lg"><hr/><div class="text-center"><a class="secondary" href="https://github.com/hgiasac"><i class="fa fa-github fa-2x"> </i></a><a class="secondary" href="https://www.linkedin.com/in/toan-nguyen-83295527/"><i class="fa fa-linkedin fa-2x"> </i></a><a class="secondary" href="https://stackoverflow.com/users/4230985/hgiasac"><i class="fa fa-stack-overflow fa-2x"> </i></a></div><div class="text-center mt-2">Â© Toan Nguyen 2017-2021</div></div></div></footer></body></html>