<html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>TimescaleDB 2.0 with Hasura Part 1: From 1.x to 2.0 (2020-12-31)</title><meta property="og:title" content="TimescaleDB 2.0 with Hasura Part 1: From 1.x to 2.0 (2020-12-31)"/><meta property="twitter:title" content="TimescaleDB 2.0 with Hasura Part 1: From 1.x to 2.0 (2020-12-31)"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,500"/><link rel="stylesheet" href="/assets/main.min.css"/><link rel="stylesheet" href="https://maxcdn.icons8.com/fonts/line-awesome/1.1/css/line-awesome-font-awesome.min.css"/></head><meta name="description" content=""/><meta property="og:description" content=""/><meta property="twitter:description" content=""/><body><header><div class="container grid-lg"><nav class="horizontal main-nav"><ul><li><a href="/">Home</a></li><li><a href="/posts">Posts</a></li><li><a href="/about.html">About</a></li><li><a href="https://www.visualcv.com/toan-nguyen">CV</a></li></ul></nav></div></header><section class="section"><div id="main"><div class="wrapper"><div class="container grid-lg"><hr class="mt-2"/><article class="article"><h1 id="TimescaleDB_20_with_Hasura_Part_1_-_From_1x_to_20">TimescaleDB 2.0 with Hasura Part 1 - From 1.x to 2.0</h1><p><img src="/assets/timescale-hasura.png" alt="Hasura TimescaleDB"/></p><p>As you probably know, <a href="https://github.com/timescale/timescaledb">TimescaleDB</a> is an open-source database designed to make SQL scalable for time-series data. The most valuable features of TimescaleDB is <code>hypertable</code>, a high-level table that provides automatic partitioning across time and space (partitioning key).</p><p>TimescaleDB 2.0 is a big major version upgrade that has many improvements from version 1. It introduces new interesting features and capabilities, especially horizontal multi-node scaling that can solve the limitation of write performance.</p><p>Because it is a PostgreSQL extension, it mostly works well with Hasura. However, there are several limitations. This article will tells you about known issues and workarounds.</p><blockquote><p>This is final part of the series:</p><ul><li><a href="/posts/2020-12-31-TimescaleDB-2.0-with-Hasura-Part-1:-From-1.x-to-2.0.html">Part 1 - From 1.x to 2.0</a></li><li><a href="/posts/2021-01-01-TimescaleDB-2.0-with-Hasura-Part-2:-Multi-node.html">Part 2 - Multi-node</a></li><li><a href="/posts/2021-01-02-TimescaleDB-2.0-with-Hasura-Part-3:-High-Availability.html">Part 3 - High availability</a></li></ul></blockquote><blockquote><p>The example code is uploaded on <a href="https://github.com/hgiasac/hasura-timescaledb2-example">Github</a></p></blockquote><h2 id="Migrations_and_Breaking_changes">Migrations and Breaking changes</h2><h3 id="From_1x_to_20">From 1.x to 2.0</h3><p>To upgrade new version, you can read <a href="https://docs.timescale.com/latest/update-timescaledb/update-tsdb-2">the official guide here</a></p><p>The following table shows syntax comparison between TimescaleDB 1.7 and 2.0:</p><p>| 1.7 | 2.0 | Comment |
| --- | --- | ------- |
| add<em>compress</em>chunks_policy | add<em>compression</em>policy | Add compression policy |
| remove<em>compress</em>chunks_policy | remove<em>compression</em>policy | Remove compression policy |
| add<em>drop</em>chunks_policy | add<em>retention</em>policy | Add retention policy |
| remove<em>drop</em>chunks_policy | remove<em>retention</em>policy | Remove retention policy |
| CREATE VIEW ... WITH (timescaledb.continuous) | CREATE MATERIALIZED VIEW ... (timescaledb.continuous); SELECT add<em>continuous</em>aggregate_policy(...); | create materialized view (continuous aggregate) |
| DROP VIEW <a href="view_name">view_name</a> CASCADE | DROP MATERIALIZED VIEW <a href="view_name">view_name</a> | Drop materialized view (continuous aggregate) |
| SELECT * FROM timescaledb_information.hypertables WHERE table_name = &#39;<a href="table_name">table_name</a>&#39; | SELECT * FROM hypertable_size(&#39;<a href="table_name">table_name</a>&#39;) | Get hypertable size |
| ^ | SELECT hypertable<em>index</em>size(&#39;<a href="table_name">table_name</a>&#39;) | Get hypertable index size |
| ^ | SELECT hypertable<em>detailed</em>size(&#39;<a href="table_name">table_name</a>&#39;) | Get hypertable index detailed size |<br/>| SELECT * FROM timescaledb_information.compressed<em>chunk</em>stats WHERE hypertable_name = &#39;<a href="table_name">table_name</a>&#39; | SELECT * FROM hypertable<em>compression</em>stats(&#39;<a href="table_name">table_name</a>&#39;) | Get compression stats |</p><p>Many of functions and SQL syntaxes are renamed. <code>timescaledb_information</code> view structures are very different. You can&#39;t list all hypertable sizes with <code>timescaledb_information.hypertables</code>, <code>timescaledb_information.compressed_hypertable_stats</code> but SELECT each table with <code>hypertable_size</code>, <code>hypertable_compression_stats</code> functions.</p><p>In version 2.0, there are 2 new interesting features:</p><ul><li>Scheduled job. Now you can run cronjob in Postgres to do many things, such as automatically refreshing Materialized view.</li><li>Multi-node. It helps us scaling read&#x2F;write into multiple data nodes.</li></ul><p>Because of scheduled job. Continuous Aggregate Materialized View has a big refactor, as well as breaking changes, that we will explore more in the next section.</p><h3 id="Materialized_View_Continuous_Aggregate">Materialized View (Continuous Aggregate)</h3><p>Continuous Aggregate Materialized View is Materialized View with auto refresh and partitioning. In migration point of view, high level SQL definition is translated to internal statements.</p><p>Input: </p><pre class="code" data-lang="sql"><code>CREATE MATERIALIZED VIEW conditions_summary_minutely<br/>    WITH (timescaledb.continuous) AS<br/>    SELECT time_bucket(INTERVAL &#39;1 minute&#39;, time) AS bucket,<br/>        AVG(temperature),<br/>        MAX(temperature),<br/>        MIN(temperature)<br/>    FROM conditions<br/>    GROUP BY bucket;</code></pre><p>Output: </p><pre class="code" data-lang="sql"><code>CREATE OR REPLACE VIEW &quot;public&quot;.&quot;conditions_summary_minutely&quot; AS<br/>SELECT<br/>  _materialized_hypertable_5.bucket,<br/>  _timescaledb_internal.finalize_agg(<br/>    &#39;avg(double precision)&#39; :: text,<br/>    NULL :: name,<br/>    NULL :: name,<br/>    &#39;{{pg_catalog,float8}}&#39; :: name [],<br/>    _materialized_hypertable_5.agg_2_2,<br/>    NULL :: double precision<br/>  ) AS avg,<br/>  _timescaledb_internal.finalize_agg(<br/>    &#39;max(double precision)&#39; :: text,<br/>    NULL :: name,<br/>    NULL :: name,<br/>    &#39;{{pg_catalog,float8}}&#39; :: name [],<br/>    _materialized_hypertable_5.agg_3_3,<br/>    NULL :: double precision<br/>  ) AS max,<br/>  _timescaledb_internal.finalize_agg(<br/>    &#39;min(double precision)&#39; :: text,<br/>    NULL :: name,<br/>    NULL :: name,<br/>    &#39;{{pg_catalog,float8}}&#39; :: name [],<br/>    _materialized_hypertable_5.agg_4_4,<br/>    NULL :: double precision<br/>  ) AS min<br/>FROM<br/>  _timescaledb_internal._materialized_hypertable_5<br/>WHERE<br/>  (<br/>    _materialized_hypertable_5.bucket &lt; COALESCE(<br/>      _timescaledb_internal.to_timestamp(_timescaledb_internal.cagg_watermark(5)),<br/>      &#39;-infinity&#39; :: timestamp with time zone<br/>    )<br/>  )<br/>GROUP BY<br/>  _materialized_hypertable_5.bucket<br/>UNION ALL<br/>SELECT<br/>  time_bucket(&#39;00:01:00&#39; :: interval, conditions.&quot;time&quot;) AS bucket,<br/>  avg(conditions.temperature) AS avg,<br/>  max(conditions.temperature) AS max,<br/>  min(conditions.temperature) AS min<br/>FROM<br/>  conditions<br/>WHERE<br/>  (<br/>    conditions.&quot;time&quot; &gt;= COALESCE(<br/>      _timescaledb_internal.to_timestamp(_timescaledb_internal.cagg_watermark(5)),<br/>      &#39;-infinity&#39; :: timestamp with time zone<br/>    )<br/>  )<br/>GROUP BY<br/>  (<br/>    time_bucket(&#39;00:01:00&#39; :: interval, conditions.&quot;time&quot;)<br/>  );</code></pre><p>It&#39;s annoyed to reuse definition in console if you lose the original script. Moreover, it doesn&#39;t support <code>CREATE OR REPLACE</code> to replace current definition, so you need to DROP and CREATE the view.</p><p>From TimescaleDB 2.0, the new API and framework for continuous aggregates separates policy from the core functionality (<a href="https://github.com/timescale/timescaledb/issues/2118">#2118</a>). The continuous view creation syntax is changed:</p><pre class="code" data-lang="sql"><code>-- old syntax<br/>CREATE VIEW conditions_summary_minutely<br/>WITH (timescaledb.continuous,<br/>    timescaledb.refresh_lag = &#39;1h&#39;,<br/>    timescaledb.refresh_interval = &#39;1h&#39;)<br/>AS<br/>    SELECT time_bucket(INTERVAL &#39;1 minute&#39;, time) AS bucket,<br/>        AVG(temperature),<br/>        MAX(temperature),<br/>        MIN(temperature)<br/>    FROM conditions<br/>    GROUP BY bucket;<br/><br/>-- new syntax<br/>CREATE MATERIALIZED VIEW conditions_summary_minutely<br/>    WITH (timescaledb.continuous) AS<br/>    SELECT time_bucket(INTERVAL &#39;1 minute&#39;, time) AS bucket,<br/>           AVG(temperature),<br/>           MAX(temperature),<br/>           MIN(temperature)<br/>    FROM conditions<br/>    GROUP BY bucket;<br/><br/>-- the continuous aggregate policy is a separated job<br/>SELECT add_continuous_aggregate_policy(&#39;conditions_summary_minutely&#39;,<br/>    start_offset =&gt; INTERVAL &#39;2 h&#39;,<br/>    end_offset =&gt; INTERVAL &#39;1 h&#39;,<br/>    schedule_interval =&gt; INTERVAL &#39;1 h&#39;);</code></pre><p>The new continuous view separates continuous aggregate policy into another function <code>add_continuous_aggregate_policy</code> instead of parameters in one <code>CREATE VIEW</code> statement. Moreover, it leads another issue:</p><pre class="code" data-lang="sql"><code>CREATE MATERIALIZED VIEW ... WITH DATA cannot run inside a transaction block</code></pre><h3 id="FatalError__cannot_run_inside_a_transaction_block">FatalError: ... cannot run inside a transaction block</h3><p>There are functions that requires running in <code>AUTOCOMMIT</code> mode. Every statement are automatically committed once submitted. <code>psql</code> turns on autocommit by default. If you ever notice that, <code>psql</code> executes SQL statements one by one. AFIAK, this error is thrown in these operations:</p><ul><li>Admin commands: CREATE&#x2F;DROP database, tablespace,...</li><li>CREATE INDEX CONCURRENTLY</li></ul><p>Now this error is appeared on new Continuous materialized view too. It isn&#39;t problem if you create views with <code>psql</code>. However, Hasura migration CLI becomes useless, because it uses transaction to apply migration files.</p><p>It isn&#39;t impossible to run migration with database driver, if it satisfies both conditions:</p><ul><li>Executes SQL statement without transaction.</li><li>Only one statement per request.</li></ul><p>Unfortunately it is hard to change GraphQL Engine source code, because it relates to core functionality of the engine. Finally I came up an idea. It is easier to customize the CLI with native Go&#39;s lib&#x2F;pq option.</p><p>This is a hack, so it isn&#39;t official in the main upstream. You can download the customized CLI <a href="https://github.com/hgiasac/graphql-engine/releases">here</a>, or try it in <a href="https://github.com/hgiasac/hasura-timescaledb2-example/tree/master/single">the single node example</a>.</p><pre class="code" data-lang="sh"><code>hasura migrate apply --disable-transaction --database-url &quot;&lt;url&gt;&quot;</code></pre><p>There are also caveats:</p><ul><li>Migration files are applied right away one by one, not applied as bulk SQL in one transaction. Therefore the migration can&#39;t be canceled. For example, you apply 3 migrations <code>A</code>, <code>B</code>, <code>C</code>. If there is any error in migration <code>C</code>, <code>A</code> and <code>B</code> were still applied.</li><li>There must be only 1 SQL statement in <code>up.sql</code> if you use special statement such as <code>CREATE MATERIALIZED VIEW</code>.</li></ul><h2 id="GraphQL">GraphQL</h2><p>Because TimescaleDB is an extension of Postgres, it is compatible with GraphQL Engine. However, there are several limitations of TimescaleDB that affect Hasura:</p><ul><li>Hypertable doesn&#39;t require Primary key. Therefore <code>&lt;hypertable_name&gt;_by_pk</code> queries, mutations and subscriptions are disabled.</li><li>GraphQL Engine doesn&#39;t support <code>UPSERT</code> for <code>hypertable</code>. In fact, <a href="https://docs.timescale.com/latest/using-timescaledb/writing-data#upsert">TimescaleDB supports UPSERT</a>, but with infer indexes only. Meanwhile popular Postgres query builder engines, ORMs use ON CONFLICT ON CONSTRAINT constraint_name statement.</li><li>Foreign key can&#39;t be point into a hypertable (although that data model isn&#39;t very common). The common is for the hypertable to have a foreign key to point to a relational table (think an object_id in the time-series is a Foreign Key to a metadata table about the object).</li><li>Although we can create manual relationship between hypertables, the query performance should be considered.</li></ul><p>(Thank Mike Freedman (<a href="https://twitter.com/michaelfreedman">@michaelfreedman</a>) for the feedback)</p><h2 id="Console_and_Hasura_CLI">Console and Hasura CLI</h2><p>TimescaleDB SQL API aren&#39;t supported by Hasura console. We have to use <code>Raw SQL</code> or create migration manually. In theory <code>hypertable</code> is the high level of table, we can create it in console. However, <code>hypertable</code> uses timestamp or number column as partition key. It requires including that column as primary key. Therefore we have to ignore primary key or use composite keys, and in practice we choose ignoring it. The issue is, Hasura console forces Primary key on table creation <a href="https://github.com/hasura/graphql-engine/issues/6235">#6235</a>. Manual migration creation is unavoidable.</p><p>However, Continuous Aggregate View can&#39;t be deleted by console UI. Behind the scene it requests <code>DROP VIEW</code> SQL execution. The correct statement is <code>DROP MATERIALIZED VIEW</code>.</p><p><img src="/assets/drop-materialized-view-error.png" alt="Drop materialized view"/></p><p>Due to optional Primary key in hypertable, we can&#39;t view detail, update and delete row in data table. </p><p><img src="/assets/timescale-hasura-console-data.png" alt="TimescaleDB Hasura console data table"/></p><p>Therefore, most of TimescaleDB functions have to be run in raw SQL. The console doesn&#39;t have many help here.</p><h2 id="Should_I_upgrade">Should I upgrade?</h2><p>Yes, if you aren&#39;t afraid of migration breaking changes. The new Continuous Materialized View is also another concern.</p><p>TimescaleDB 2.0 is also worth to upgrade with Multi-node scaling solution. We will explore in the next part of series: <a href="/posts/2021-01-01-Timescale-2-with-Hasura-Part-2:-Multi-node.html">Part 2 - Multi-node</a></p></article></div></div></div></section><footer><div class="wrapper"><div class="container grid-lg"><hr/><div class="text-center"><a class="secondary" href="https://github.com/hgiasac"><i class="fa fa-github fa-2x"> </i></a><a class="secondary" href="https://www.linkedin.com/in/toan-nguyen-83295527/"><i class="fa fa-linkedin fa-2x"> </i></a><a class="secondary" href="https://stackoverflow.com/users/4230985/hgiasac"><i class="fa fa-stack-overflow fa-2x"> </i></a></div><div class="text-center mt-2">© Toan Nguyen 2017-2021</div></div></div></footer></body></html>