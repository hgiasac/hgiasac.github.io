<html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Typeable - A long journey to Type-Safe Dynamic Type Representations (2019-01-04)</title><meta property="og:title" content="Typeable - A long journey to Type-Safe Dynamic Type Representations (2019-01-04)"/><meta property="twitter:title" content="Typeable - A long journey to Type-Safe Dynamic Type Representations (2019-01-04)"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,500"/><link rel="stylesheet" href="/assets/main.min.css"/><link rel="stylesheet" href="https://maxcdn.icons8.com/fonts/line-awesome/1.1/css/line-awesome-font-awesome.min.css"/></head><meta name="description" content="Haskell has grown and changed amazingly in recent years, with great contribution from community and industrial adoption. There are many new ideas and changes in new GHC versions, as well as breaking changes..."/><meta property="og:description" content="Haskell has grown and changed amazingly in recent years, with great contribution from community and industrial adoption. There are many new ideas and changes in new GHC versions, as well as breaking changes..."/><meta property="twitter:description" content="Haskell has grown and changed amazingly in recent years, with great contribution from community and industrial adoption. There are many new ideas and changes in new GHC versions, as well as breaking changes..."/><body><header><div class="container grid-lg"><nav class="horizontal main-nav"><ul><li><a href="/">Home</a></li><li><a href="/works.html">Works</a></li><li><a href="/posts">Posts</a></li><li><a href="/about.html">About</a></li><li><a href="https://www.visualcv.com/toan-nguyen">CV</a></li></ul></nav></div></header><section class="section"><div id="main"><div class="wrapper"><div class="container grid-lg"><hr class="mt-2"/><article class="article"><h1 id="Typeable_-_A_long_journey_to_type-safe_dynamic_type_representation">Typeable - A long journey to type-safe dynamic type representation</h1><p>Haskell has grown and changed amazingly in recent years, with great contribution from community and industrial adoption. There are many new ideas and changes in new GHC versions, as well as breaking changes. The most influent library is <code>base</code> package, which contains the Standard Haskell Prelude, and its support libraries, and a large collection of useful libraries ranging from data structures to parsing combinators and debugging utilities. (<a href="http://hackage.haskell.org/package/base-4.12.0.0">hackage</a>)</p><p><a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Typeable.html">Typeable</a> is a module in <code>base</code> package. Maybe you already know, the <code>Typeable</code> class is used to create runtime type information for arbitrary types. Explicitly, <code>Typeable</code> is a unique <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Fingerprint.html">Fingerprint</a> (or hash) of type coupled with a coercion. This module has big influence in <code>Data.Dynamic</code>, <code>Data.Data</code> module as well as generic programming libraries. This post gives you a short story about the innovation of <code>Typeable</code> along with GHC extensions.</p><h2 id="A_long_time_ago">A long time ago...</h2><p><code>Typeable</code> was originally a part of <code>Dynamic</code>, which is the solution for Dynamic typing in Statically typed language. In real world, there are programming situations we need to deal with data whose type cannot be determined at compile time, for example, fetch data from API, parse JSON string, query from database... </p><p>Since mid-1960s, early programming languages (Algol-68, Pascal, Simula-67) used similar technique of <code>Dynamic</code>. Until 1989, <code>Dynamic</code> and <code>typecase</code> term was introduced in <a href="http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-47.pdf">&quot;Dynamic Typing in a Statically Typed Language&quot;</a> paper, with lambda calculus notation.</p><p>In Haskell, from what I saw in <a href="http://git.haskell.org/packages/base.git/history/HEAD:/Data/Dynamic.hs">git.haskell.org</a>, the first commit was in June 28, 2001 by <a href="https://simonmar.github.io">Simon Marlow</a>. However, I&#39;m not sure this proof is correct. Maybe the module was implemented before that. Unfortunately I can&#39;t find another reliable source. In this version, <code>Typeable</code> and <code>Dynamic</code> were in same module. In <a href="http://git.haskell.org/packages/base.git/history/HEAD:/Data/Typeable.hs">July 24 2003</a>, <code>Typeable</code> was moved to <code>Data.Typeable</code> package. </p><p>In the early stage of Haskell, <code>TypeRep</code> was constructed of <code>TyCon</code> and child <code>TypeRep</code>s. <code>TyCon</code> hold <code>Key</code> as an unique <code>HashTable</code>, and a <code>String</code> to determine type name at user level. </p><pre class="code" data-lang="haskell"><code>data TypeRep = TypeRep !Key TyCon [TypeRep] <br/><br/>data TyCon = TyCon !Key String<br/><br/>mkTyCon :: String  -&gt; TyCon <br/><br/>boolTc :: TyCon<br/>boolTc = mkTyCon &quot;Bool&quot;<br/><br/>class Typeable a where<br/>  typeOf :: a -&gt; TypeRep<br/><br/>&gt; show $ typeOf (True :: Bool) -- Bool<br/></code></pre><p>FFI C macros can help generating instances, with some exceptions, such as <code>Tuple</code>. <code>undefined</code> was used as an alternative for Proxy. <code>unsafeCoerce</code> was used anywhere for coercing types.</p><pre class="code" data-lang="haskell"><code><br/>INSTANCE_TYPEABLE0(Bool,boolTc,&quot;Bool&quot;)<br/><br/>tup2Tc :: TyCon<br/>tup2Tc = mkTyCon &quot;,&quot;<br/><br/>instance (Typeable a, Typeable b) =&gt; Typeable (a,b) where<br/>  typeOf tu = mkAppTy tup2Tc [typeOf ((undefined :: (a,b) -&gt; a) tu),<br/>                              typeOf ((undefined :: (a,b) -&gt; b) tu)]<br/> <br/>tup3Tc :: TyCon<br/>tup3Tc = mkTyCon &quot;,,&quot;<br/><br/>instance ( Typeable a , Typeable b , Typeable c) =&gt; Typeable (a,b,c) where<br/>  ...<br/><br/>tup4Tc :: TyCon<br/>tup4Tc = mkTyCon &quot;,,,&quot; -- too much boilerplate</code></pre><h2 id="From_Key_to_Fingerprint">From Key to Fingerprint</h2><p><code>TyCon</code> was stored in unsafe IORef cache, which internally kept a <code>HashTable</code> mapping <code>String</code>s to <code>Int</code>s. So that each <code>TyCon</code> could be given a unique Int for fast comparison, the <code>String</code> has to be unique across all types in the program. However, derived instances of typeable used the qualified original name (e.g. <code>GHC.Types.Int</code>) which is not necessarily unique, is non-portable, and exposes implementation details.</p><pre class="code" data-lang="haskell"><code>newtype Key = Key Int deriving( Eq )<br/><br/>data KeyPr = KeyPr !Key !Key deriving( Eq )<br/><br/>data Cache = Cache { next_key :: !(IORef Key),<br/>                     tc_tbl   :: !(HT.HashTable String Key),<br/>                     ap_tbl   :: !(HT.HashTable KeyPr Key) <br/>                   }</code></pre><p>In July 2011, <a href="https://simonmar.github.io">Simon Marlow</a> replaced <code>Key</code> with <a href="">Fingerprint</a> - , and moved <code>TyCon</code> as well as <code>TypeRep</code> internally. The fields of TyCon are not exposed via the public API. Together the three fields <code>tyConPackage</code>, <code>tyConModule</code> and <code>tyConName</code> uniquely identify a <code>TyCon</code>, and the Fingerprint is a hash of the concatenation of these three Strings (so no more internal cache to map strings to unique IDs). This implementation is also easier for GHC to generate derived instances</p><pre class="code" data-lang="haskell"><code>data TyCon = TyCon {<br/>   tyConHash    :: {-# UNPACK #-} !Fingerprint,<br/>   tyConPackage :: String,<br/>   tyConModule  :: String,<br/>   tyConName    :: String<br/>}<br/><br/>data TypeRep = TypeRep {-# UNPACK #-} !Fingerprint TyCon [TypeRep]</code></pre><h2 id="Merge_all_the_things_">Merge all the things </h2><p>With the rise of Type-level programming, GHC compiler is more and more better. Many boilerplate codes were refactored and optimized in safe and well-performed. <code>Typeable</code> also took advantage of new GHC features:</p><h3 id="PolyKinds">PolyKinds</h3><ul><li><a href="https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/kind-polymorphism-and-promotion.html">PolyKinds</a> extension has been implemented since <a href="https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/release-7-4-1.html">GHC 7.4.1 (February 2012)</a>. Until <a href="https://ghc.haskell.org/trac/ghc/wiki/TypeLevelReasoning">GHC 7.6.1 (September 2012)</a> release, Polymorphic kinds and data promotion were fully implemented and supported features.</li><li>November 2012, <a href="https://twitter.com/dreixel">José Pedro Magalhães @dreixel</a> <a href="http://hauptwerk.blogspot.com/2012/11/coming-soon-in-ghc-head-poly-kinded.html">adapted poly-kinded into Typeable</a>, then released in <a href="https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/release-7-8-1.html">GHC 7.8.1 (April 2014) - base-4.7.0.0</a></li></ul><p>Before Poly-kinds, there are many duplicated code to support variant for N-ary type constructors. To represent type constructors with kind
<code>* -&gt; *</code>, such as <code>Maybe</code> or <code>[]</code>, we could create a separate type class, called <code>Typeable1</code>. However, this approach is ugly and inflexible. What about tuples? Do we need a <code>Typeable2</code>, <code>Typeable3</code>... for them?</p><pre class="code" data-lang="haskell"><code>class Typeable (t :: *) where<br/>  typeOf :: t -&gt; TypeRep<br/><br/>class Typeable1 (t :: * -&gt; *) where<br/>  typeOf1 :: t a -&gt; TypeRep<br/><br/>...<br/><br/>-- The maximum number of parameters was 7 <br/>class Typeable7 (t :: * -&gt; * -&gt; * -&gt; * -&gt; * -&gt; * -&gt; * -&gt; *) where<br/>  typeOf7 :: t a b c d e f g -&gt; TypeRep</code></pre><p>With kind polymorphism we can write:</p><pre class="code" data-lang="haskell"><code>class Typeable a where<br/>  typeRep :: proxy a -&gt; TypeRep<br/><br/>typeOf :: forall a. Typeable a =&gt; a -&gt; TypeRep<br/>  typeOf _ = typeRep (Proxy :: Proxy a)</code></pre><p>We have generalized in two ways here. </p><ul><li>First, <code>Typeable</code> gets <code>a</code> polymorphic kind: <code>forall a. a -&gt; Constraint</code>, so that it can be used for types of any kind. </li><li>Second, we need some way to generalize the argument of <code>typeRep</code> , which we have done via a poly-kinded data type Proxy: </li></ul><pre class="code" data-lang="haskell"><code>data Proxy a = Proxy`</code></pre><p>The idea is that, say <code>typeRep (Proxy :: Proxy Int)</code> will return the type representation for <code>Int</code>, while <code>typeRep (Proxy :: Proxy Maybe)</code> will do the same for <code>Maybe</code>. The proxy argument carries no information—the type has only one, nullary constructor and is only present so that the programmer can express the type at which to invoke <code>typeRep</code>. Because there are no constraints on the kind of <code>a</code>, it is safe to assign <code>Proxy</code> the polymorphic kind <code>forall a. a -&gt; *</code>.</p><h3 id="TypeLevelReasoning">TypeLevelReasoning</h3><p><a href="https://cs.brynmawr.edu/~rae/">Richard A. Eisenberg</a> also proposed and implemented <a href="https://ghc.haskell.org/trac/ghc/wiki/TypeLevelReasoning">TypeLevelReasoning</a>. New module <code>Data.Type.Equality</code> was born. The idea is defines the type of equality witnesses for two types of any kind <code>k</code>:</p><pre class="code" data-lang="haskell"><code>data a :~: b where<br/>  Refl :: a :~: a</code></pre><p>Pattern matching on this generalized algebraic datatype (GADT) allows GHC to discover the equality between two types. If <code>a :=: b</code> is inhabited by some terminating value, then the type <code>a</code> is the same as the type <code>b</code>. To use this equality in practice, pattern-match on the <code>a :=: b</code> to get out the <code>Refl</code> constructor:</p><pre class="code" data-lang="haskell"><code>coerce :: (a :~: b) -&gt; a -&gt; b<br/>  coerce Refl x = x</code></pre><p>We pattern-match on <code>Refl</code>. This exposes the fact that <code>a</code> and <code>b</code> must be the same. Then, GHC happily uses <code>x</code> of type <code>a</code> in a context expecting something of type <code>b</code>.</p><p>With this, we can remove unsafe hack when convert Proxy:</p><pre class="code" data-lang="haskell"><code>-- no equality<br/>cast :: (Typeable a, Typeable b) =&gt; a -&gt; Maybe b<br/>cast x = r<br/>  where<br/>    r = if typeOf x == typeOf (fromJust r)<br/>        then Just $ unsafeCoerce x<br/>        else Nothing<br/><br/>-- with equality<br/>eqT :: forall a b. (Typeable a, Typeable b) =&gt; Maybe (a :~: b)<br/>eqT = if typeRep (Proxy :: Proxy a) == typeRep (Proxy :: Proxy b)<br/>      then Just $ unsafeCoerce Refl<br/>      else Nothing<br/> <br/>cast :: forall a b. (Typeable a, Typeable b) =&gt; a -&gt; Maybe b<br/>cast x<br/>  | Just Refl &lt;- ta `eqT` tb = Just x<br/>  | otherwise                 = Nothing<br/>  where<br/>    ta = typeRep :: TypeRep a<br/>    tb = typeRep :: TypeRep b</code></pre><h3 id="And_more">And more...</h3><p>This release also added is the <code>AutoDeriveTypeable</code> language extension, which will automatically derive <code>Typeable</code> for all types and classes declared in that module.</p><p>The update could caused breaking changes, although backwards compatibility interfaces were kept. José Pedro Magalhães also backed up old codes into <code>Data.OldTypeable</code> module, which was removed later in <a href="http://hackage.haskell.org/package/base-4.8.0.0/changelog">GHC 7.10.1 - base-4.8.0.0</a></p><ul><li>Since GHC 8.2, GHC has supported type-indexed type representations. <code>Data.Typeable</code> provides type representations which are qualified over this index. To keep <code>Typeable</code> backwards compatibility, the interface of this module is similar to old releases. <code>Type.Reflection</code> module is available for the type-indexed interface.</li></ul><h2 id="Safer_and_more_expressive_type_representations">Safer and more expressive type representations</h2><p>With the motivation of distribution programming, mainly focusing on <a href="https://wiki.haskell.org/Cloud_Haskell">Cloud Haskell</a>, new challenges occurred: Typeable wasn&#39;t safe enough.</p><h3 id="Open_worlds_challenge">Open world&#39;s challenge</h3><p><a href="https://wiki.haskell.org/Cloud_Haskell">Cloud Haskell</a> is an Erlang-style library for programming a distributed system in Haskell. It is based on the message-passing model of Erlang, but with additional advantages that stem from Haskell’s purity, types, and monads. If you are from Scala land, Cloud Haskell has similar features with <a href="https://akka.io">Akka</a>, which use Actor model for communicating across processes. However, Cloud Haskell also supports thread in same machine. You can conveniently do things the old way.</p><p>Because the information that is transmitted between machines by network must be in bit, the data must be <code>Serializable</code>. This ensures two properties: The data can be encoded and decoded to binary fore and back, and can produce a <code>TypeRep</code> that captures the item’s type.</p><pre class="code" data-lang="haskell"><code>class (Typeable a, Binary a) =&gt; Serializable a<br/><br/>class Binary a where<br/>  put :: t -&gt; PutM ()<br/>  get :: Get t<br/><br/>class Typeable a where<br/>  typeOf :: a -&gt; TypeRep<br/><br/>encode :: a -&gt; ByteString<br/>decode :: ByteString -&gt; Maybe (a, ByteString)</code></pre><p>To guarantee that the code is then applied to appropriately typed values, the receiving node must perform a dynamic type test. That way, even if the code pointer was corrupted in transit, by accident or malice, the receiving node will be type-sound. You can think of it like this: a decoder is simply a parser for the bits in the <code>ByteString</code>, so a decoder for <code>Int</code> can fail to parse a full <code>Int</code> (returning <code>Nothing</code>), but it can&#39;t return a non-Int. A simple way to do this is to serialize a code pointer as a key into a static pointer table containing Dynamic values (<a href="https://hackage.haskell.org/package/distributed-static-0.3.8/docs/Control-Distributed-Static.html#v:unstatic">RemoteTable</a>). When receiving code pointer with key <code>k</code>, the recipient can lookup up entry <code>k</code> in the table, find a <code>Dynamic</code>, and check that it has the expected type.</p><p>To do that, <code>Typeable</code> needed to evolve further.</p><p><code>TypeRep</code> was not indexed, so there was no connection between the <code>TypeRep</code> stored in a <code>Dynamic</code> and the corresponding value. Indeed, accessing the <code>typeRep</code> required a proxy argument to specify the type that should be represented.</p><pre class="code" data-lang="haskell"><code>data TypeRep <br/><br/>data Typeable a where<br/>  typeRep :: proxy a -&gt; TypeRep<br/><br/>data Dynamic where<br/>  Dyn :: TypeRep -&gt; a -&gt; Dynamic <br/><br/>data Proxy a = Proxy</code></pre><p>Because there is no connection between types and their representations, this implementation of <code>Dynamic</code> requires <code>unsafeCoerce</code>. For example, here is the old <code>fromDynamic</code>:</p><pre class="code" data-lang="haskell"><code>fromDynamic :: forall d. Typeable d =&gt; Dynamic -&gt; Maybe d <br/>fromDynamic (Dyn trx x)<br/>  | typeRep (Proxy :: Proxy d) == trx = Just (unsafeCoerce x)<br/>  | otherwise = Nothing</code></pre><p>Client code is un-trusted. The current design (GHC 7.8) couldn&#39;t hide all such uses of <code>unsafeCoerce</code> from the user. If they could write a <code>Typeable</code> instance, they must use <code>unsafeCoerce</code>, and defeat type safety. So only GHC is allowed write <code>Typeable</code> instances. </p><h3 id="Kind-indexed_GADTs">Kind-indexed GADTs</h3><p>The key to our approach is our type-indexed type representation <code>TypeRep</code>. But what is a type-indexed type representation? That is, the index in a type-indexed type representation is itself the represented type. For example:</p><ul><li>The representation of <code>Int</code> is the value of type <code>TypeRep Int</code>.</li></ul><p>– The representation of <code>Bool</code> is the value of type <code>TypeRep Bool</code>.</p><ul><li>And so on.</li></ul><p>The idea of kind-indexed is originally from GADTs. For example, we consider designing a GADT for closed type representations:</p><pre class="code" data-lang="haskell"><code>data TyRep :: * -&gt; * where<br/>  TyInt  :: TyRep Int<br/>  TyBool :: TyRep Bool</code></pre><p>GADTs differ from ordinary algebraic data types in that they allow each data constructor to constrain the type parameters to the datatype. For example, the <code>TyInt</code> constructor requires that the single parameter to <code>TyRep</code> be <code>Int</code>.</p><p>We can use type representations for type-indexed programming a simple example liked computing a default element for each type.</p><pre class="code" data-lang="haskell"><code>zero :: forall a. TyRep a -&gt; a<br/>zero TyInt  = 0          -- ‘a’ must be Int<br/>zero TyBool = False      -- ‘a’ must be Bool</code></pre><p>This code pattern matches the type representation to determine what value to return. Because of the nonuniform type index, pattern matching recovers the identity of the type variable <code>a</code>. </p><ul><li>In the first case, because the data constructor is <code>TyInt</code>, this parameter must be <code>Int</code>, so <code>0</code> can be returned. </li><li>In the second case, the parameter <code>a</code> must be equal to <code>Bool</code>, so returning <code>False</code> is well-typed.</li></ul><p>However, the GADT above can only be used to represent types of kind <code>*</code>. To represent type constructors with kind <code>* -&gt; *</code>, such as <code>Maybe</code> or <code>[]</code>, we could create a separate datatype, perhaps called <code>TyRep1</code>, <code>TyRep2</code>,... Kind polymorphism which allows data types to be parameterized by kind variables as well as type variables, could be the solution. However, it is not enough to unify the representations for <code>TyRep</code>. the type representation (shown below) should constrain its kind parameter.</p><pre class="code" data-lang="haskell"><code>data TyRep (a :: k) where<br/>  TyInt :: TyRep Int<br/>  TyBool :: TyRep Bool<br/>  TyMaybe :: TyRep Maybe<br/>  TyApp :: TyRep b -&gt; TyRep c -&gt; TyRep (b c)</code></pre><p>This <code>TyRep</code> type takes two parameters, a kind <code>k</code> and a type of that kind (not named in the kind annotation). The data constructors constrain
<code>k</code> to a concrete kind. For the example to be well-formed, <code>TyInt</code> must constrain the kind parameter to *. Similarly, <code>TyMaybe</code> requires the kind parameter to be <code>* -&gt; *</code>. We call this example a kind-indexed GADT because the datatype is indexed by both kind and type information.</p><p>Pattern matching with this datatype refines kinds as well as types—determining whether a type is of the form <code>TyApp</code> makes new kind and type equalities available. For example, consider the zero function extended with a default value of the <code>Maybe</code> type.</p><pre class="code" data-lang="haskell"><code>zero :: forall (a :: *). TyRep a -&gt; a<br/>zero TyInt = 0<br/>zero TyBool = False<br/>zero TyApp (TyMaybe _) = Nothing</code></pre><p>In the last case, the <code>TyApp</code> pattern introduces the kind variable <code>k</code>, the type variables <code>b :: k -&gt; *</code> and <code>c :: k</code>, and the type equality <code>a ∼ b c</code>. The <code>TyMaybe</code> pattern adds the kind equality <code>k ~ *</code> and type equality <code>b ∼ Maybe</code>. Combining the equality, we can show that <code>Maybe c</code>, the type of <code>Nothing</code>, is well-kinded and equal to <code>a</code>. </p><p>With this design, we also enable type decomposition feature. Finally, new <code>TypeRep</code> will be:</p><pre class="code" data-lang="haskell"><code>data TypeRep (a :: k) where<br/>  TrTyCon :: !Fingerprint -&gt; TyCon -&gt; TypeRep k -&gt; TypeRep a<br/>  TrApp   :: !Fingerprint -&gt; TypeRep a -&gt; TypeRep b -&gt; TypeRep (a b)<br/><br/>data TyCon = TyCon { tc_module :: Module, tc_name :: String }<br/>data Module = Module { mod_pkg :: String, mod_name :: String }<br/></code></pre><p>The current implementation of <code>TypeRep</code> allows constant-time comparison based on fingerprints. To support this in the new scheme we would want to add a fingerprint to every TypeRep node. But we would not want clients to see those fingerprints. </p><p>The <code>TyCon</code> type, which is a runtime representation of the “identity” of a type constructor, is now silently generates a binding for a suitable instance for every datatype declaration by GHC. For example, for <code>Maybe</code> GHC will generate:</p><pre class="code" data-lang="haskell"><code>$tcMaybe :: TyCon <br/>$tcMaybe = TyCon { tc_module = Module { mod_pkg = &quot;base&quot;<br/>                                      , mod_name = &quot;Data.Maybe&quot;<br/>                                      }<br/>                 , tc_name = &quot;Maybe&quot;<br/>                 }</code></pre><p>The name <code>$tcMaybe</code> is not directly available to the programmer. Instead (this is the second piece of built-in support), GHC’s type-constraint solver has special behavior for <code>Typeable</code> constraints, as follows.</p><p>To solve <code>Typeable(t1 t2)</code>, GHC simply solves <code>Typeable t1</code> and <code>Typeable t2</code>, and combines the results with <code>TrApp</code>. To solve <code>Typeable T</code> where <code>T</code> is a type constructor, the solver uses <code>TrTyCon</code>. The first argument of <code>TrTyCon</code> is straight-forward: it is the (runtime representation of the) type constructor itself, e.g <code>$tcMaybe</code>.</p><p>But <code>TrTyCon</code> also stores the representation of the kind of this very constructor, of type <code>TypeRep k</code>. Recording the kind representations is important, otherwise we would not be able to distinguish, say, <code>Proxy :: * -&gt; *</code> from <code>Proxy :: (* -&gt; *) -&gt; *</code>, where Proxy has a polymorphic kind <code>(Proxy :: forall k. k -&gt; *)</code>. We do not support direct representations of kind-polymorphic constructors like <code>Proxy</code>, rather
<code>TrTyCon</code> encodes the instantiation of a kind-polymorphic constructor (such as Proxy).</p><p>Notice that <code>TrTyCon</code> is fundamentally insecure: you could use it to build a <code>TypeRep t</code> for any <code>t</code> whatsoever. That is why we do not expose the representation of <code>TypeRep</code> to the programmer. Instead the part of GHC’s Typeable solver that builds <code>TrTyCon</code> applications is part of GHC’s trusted code base. </p><p><code>TypeRep</code> is abstract, and thus we don&#39;t use proxy to determine the <code>TypeRep</code> value anymore:</p><pre class="code" data-lang="haskell"><code>-- before<br/>class Typeable a where<br/>  typeRep :: proxy a -&gt; TypeRep<br/><br/>-- after<br/>data Typeable a where<br/>  typeRep :: TypeRep</code></pre><h3 id="Kind_equalities">Kind equalities</h3><p>We also need to recompute representation equality function <code>eqT</code>. It is easy, just need to compare equality between 2 <code>TypeRep</code> fingerprint:</p><pre class="code" data-lang="haskell"><code>data (a :: k1) :~~: (a :: k2) where<br/>  HRefl :: forall (a :: k). a :~~: a<br/><br/>eqT :: forall k1 k2 (a :: k1) (b :: k2)<br/>        . TypeRep a -&gt; TypeRep b -&gt; Maybe (a :~~: b)<br/>eqT a b <br/>  | typeRepFingerprint a == typeRepFingerprint b = Just (unsafeCoerce Refl)<br/>  | otherwise = Nothing</code></pre><p>It is critical that this function returns <code>(:~~:)</code>, not <code>(:~:)</code>. GHC can&#39;t compile. This is because <code>TyCon</code>s exist at many different kinds. For example, <code>Int</code> is at kind <code>*</code>, and <code>Maybe</code> is at kind <code>* -&gt; *</code>. Thus, when comparing two <code>TyCon</code> representations for equality, we want to learn whether the types and the kinds are equal. If we used type equalities <code>(:~:)</code> here, the <code>eqTypeRep</code> function could be used only when we know, from some other source, that the kinds are equal. </p><p><a href="https://cs.brynmawr.edu/~rae/">Richard A. Eisenberg</a> proposed and implemented <a href="https://cs.brynmawr.edu/~rae/papers/2015/equalities/equalities.pdf">kind heterogeneous equalities</a> (2013 - 2015). It enable new, useful features such as kind-indexed GADTs, promoted GADTs and kind families. This extension was experiment in GHC 8.0.1, then was provided in <code>Data.Type.Equality</code> module.</p><p>The restriction above exists because GHC reasons about only type equality, never kind equality. The solution to all of these problems is simple to state: merge the concepts of type and kind. If types and kinds are the same, then we surely have kind equalities. In order to overcome those challenges, it has been necessary to augment GHC’s internal language, <code>System FC</code>. This is beyond the scope of this post. If you need to dig into detail, let&#39;s <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.19.7113&rep=rep1&type=pdf">read this paper</a>.</p><p><code>fromDynamic</code> turns out like this:</p><pre class="code" data-lang="haskell"><code>fromDynamic :: forall d. Typeable d =&gt; Dynamic -&gt; Maybe d<br/>fromDynamic (Dyn (ra :: TypeRep a) (x :: a))<br/>  = case eqT ra (typeRep :: TypeRep d) of <br/>      Nothing -&gt; Nothing<br/>      Just HRefl -&gt; Just x</code></pre><p>We use <code>eqT</code> to compare the two <code>TypeRep</code>s, and pattern-match on <code>HRefl</code>, so that in the second case alternative we know that <code>a</code> and <code>d</code> are equal, so we can return <code>Just x</code> where a value of type <code>Maybe d</code> is needed. More generally, <code>eqT</code> allows to implement type-safe cast, a useful operation in its own right.</p><h3 id="Decomposing_polykinds_representations">Decomposing polykinds representations</h3><p>So far, we have discussed type representations for only types of kind <code>*</code>. The only operation we have provided over <code>TypeRep</code> is <code>eqT</code>, which compares two type representations for equality. Does <code>(,)</code> which has kind <code>(* -&gt; *)</code> too have a <code>TypeRep</code>? For example, how can we decompose the type representation, to check that it indeed represents a pair, and extract its first component? </p><pre class="code" data-lang="haskell"><code>dynFst :: Dynamic -&gt; Maybe Dynamic<br/>dynFst (Dyn rpab x)<br/>  = ...</code></pre><p>Of course it must. Since types in Haskell are built via a sequence of type applications (much like how an expression applying a function to multiple arguments is built with several nested term applications), the natural dual is to provide a way to decompose type applications. Let&#39;s take a look at <code>TrApp</code> definition:</p><pre class="code" data-lang="haskell"><code>data TypeRep a where  <br/>  TrCon :: !Fingerprint -&gt; TyCon -&gt; TypeRep k -&gt; TypeRep a<br/>  TrApp :: !Fingerprint -&gt; TypeRep a -&gt; TypeRep b -&gt; TypeRep (a b)</code></pre><p><code>TrApp</code> allows us to observe the structure of types and expose the type equalities it has discovered to the type checker. Now we can implement
<code>dynFst</code>:</p><pre class="code" data-lang="haskell"><code>dynFst :: Dynamic -&gt; Maybe Dynamic<br/>dynFst (Dyn (TrApp _ rpa rb) x) <br/>  = case rpa of <br/>      TrApp rp ra -&gt; case eqT rp (typeRep :: TypeRep (,)) of<br/>                      Just Refl -&gt; Just $ Dyn ra (fst x)<br/>                      Nothing -&gt; Nothing<br/>      _ -&gt; Nothing<br/>dynFst _ = Nothing</code></pre><p>We check that the <code>TypeRep</code> of x is of form <code>(,) a b</code> by decomposing it twice. Then we must check that <code>rp</code>, the <code>TypeRep</code> of the function part of this application, is indeed the pair type constructor <code>(,)</code>; we can do that using <code>eqT</code>. These three GADT pattern matches combine to tell the type checker that the type of <code>x</code>, which began life in the <code>(Dyn rpab x)</code> pattern match as an existentially-quantified type variable, is indeed a pair type <code>(a, b)</code>. So we can safely apply <code>fst</code> to <code>x</code>, to get a result whose type representation <code>ra</code> we have in hand.</p><p>The code is simple enough, but the type checker has to work remarkably hard behind the scenes to prove that it is sound. Let us take a closer
look with kind signatures added:</p><pre class="code" data-lang="haskell"><code>data TypeRep a where <br/>  TrApp :: forall k1 k2 (a :: k1 -&gt; k2) (b :: k1) <br/>         . !Fingerprint -&gt; TypeRep a -&gt; TypeRep b -&gt; TypeRep (a b)</code></pre><p>Note that <code>k1</code>, the kind of <code>b</code> is <em>existentially</em> bound in this data structure, meaning that it does not appear in the kind of the result type <code>(a b)</code>. We know the result kind of the type application but there is no way to know the kinds of the sub-components.</p><p>With kind polymorphism in mind, let’s add some type annotations to see what existential variables are introduced in <code>dynFst</code>:</p><pre class="code" data-lang="haskell"><code><br/>dynFst :: Dynamic -&gt; Maybe Dynamic<br/>-- dynFst (Dyn (rpab :: TypeRep pab) (x :: pab))<br/>dynFst (Dyn (TrApp _ (rpa :: TypeRep pa) (rb :: TypeRep b)) (x :: pab)) <br/>  -- introduces kind k2, and types pa :: k2 -&gt; *; b :: k2<br/>  = case rpa of <br/>      TrApp (rp :: TypeRep p) (ra :: TypeRep a) -&gt; <br/>        -- introduces kind k1, and types p :: k1 -&gt; k2 -&gt; *, a :: k1<br/>        case eqT rp (typeRep :: TypeRep (,)) of<br/>          Just Refl -&gt; Just $ Dyn ra (fst x)<br/>          -- introduces p ~ (,) and (k1 -&gt; k2 -&gt; *) ~ (* -&gt; * -&gt; *)<br/>          Nothing -&gt; Nothing<br/>      _ -&gt; Nothing<br/>dynFst _ = Nothing</code></pre><p>Focus on the arguments to the call to <code>eqT</code> in the third line. We know that:</p><ul><li>rp :: TypeRep p and p :: k1 -&gt; k2 -&gt; *</li><li>typeRep :: TypeRep (,) and (,) :: * -&gt; * -&gt; *</li></ul><p>So <code>eqT</code> must compare the <code>TypeRep</code>s for two types of different kinds; if the runtime test succeeds, we know not only that <code>p ~ (,)</code>, but also that <code>(k1 ~ *)</code> and <code>(k2 ~ *)</code>. That is, the pattern match on <code>Refl</code> GADT constructor brings local kind equalities into scope, as well as type equalities.</p><h3 id="Better_Pattern_matching_with_PatternSynonyms">Better Pattern matching with PatternSynonyms</h3><p>The code above is ugly. Moreover, we don&#39;t want to expose <code>TypeRep</code> constructor to users. Earliest solution is returning another GADT:</p><pre class="code" data-lang="haskell"><code>data AppResult t where<br/>  App :: TypeRep a -&gt; TypeRep b -&gt; AppResult (a b)<br/><br/>splitApp :: TypeRep a -&gt; Maybe (AppResult a)<br/>splitApp (TrApp _ ra rb) = Just $ App ra rb<br/>splitApp _               = Nothing<br/><br/>dynFst :: Dynamic -&gt; Maybe Dynamic<br/>dynFst (Dyn rpab x) = do <br/>  App rpa rb &lt;- splitApp rpab<br/>  App rp ra &lt;- splitApp rpa<br/>  Refl &lt;- eqT rp (typeRep :: TypeRep (,))<br/>  return $ Dyn ra (fst x)</code></pre><p>However, we can make it better with <code>PatternSynonyms</code> extension which was provided since GHC 7.8.</p><blockquote><p>Pattern synonyms enable giving names to parametrized pattern schemes. They can also be thought of as abstract constructors that don’t have a bearing on data representation.
<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-PatternSynonyms">GHC User&#39;s Guide</a></p></blockquote><pre class="code" data-lang="haskell"><code>pattern App :: forall k2 (t :: k2). ()<br/>            =&gt; forall k1 (a :: k1 -&gt; k2) (b :: k1). (t ~ a b)<br/>            =&gt; TypeRep a -&gt; TypeRep b -&gt; TypeRep t<br/>pattern App f x &lt;- TrApp _ f x<br/>  where App f x = mkTrApp f x<br/><br/><br/>dynFst :: Dynamic -&gt; Maybe Dynamic<br/>dynFst (Dyn (App (App rp ra) rb) x) = do<br/>  Refl &lt;- eqT rp (typeRep :: TypeRep (,))<br/>  return $ Dyn ra (fst x)<br/>dynFst _                            = Nothing</code></pre><p>With this extension, you can not only hide the representation of the datatype, but also use it in pattern matching. Our code is much cleaner.</p><h3 id="Decompose_function_type_TypeInType_and_Dependent_Types">Decompose function type, TypeInType and Dependent Types</h3><p>We also need to implement <code>dynApply</code>, which applies a function Dynamic to an argument Dynamic. It is necessary in real-world application, e.g, send an object with a function type, say <code>Bool -&gt; Int</code>, over the network.</p><pre class="code" data-lang="haskell"><code>dynApply :: Dynamic -&gt; Dynamic -&gt; Maybe Dynamic<br/>dynApply (Dyn rf f) (Dyn rx x) = ?</code></pre><p>In theory, We can use <code>TrApp</code> and <code>App</code> pattern to construct and decompose function type <code>(-&gt;)</code> too. The definition of this function is fairly
straightforward:</p><pre class="code" data-lang="haskell"><code>dynApply :: Dynamic -&gt; Dynamic -&gt; Maybe Dynamic<br/>dynApply (Dyn (TrApp (TrApp tr targ) tres) fun) (Dyn targ&#39; arg)<br/>  | Just HRefl &lt;- eqT tr (typeRep :: TypeRep (-&gt;))<br/>  , Just HRefl &lt;- eqT targ targ&#39;<br/>  = Just (Dyn tres (fun arg))<br/>dynApply _ _ = Nothing</code></pre><p>However, because functions are quite ubiquitous, we should define another constructor for the sake of efficiency:</p><pre class="code" data-lang="haskell"><code>data TypeRep (a :: k) where <br/>  TrFun :: TypeRep a -&gt; TypeRep b -&gt; TypeRep (a -&gt; b)</code></pre><p>This definition wasn&#39;t compiled before GHC 8.0. First, <code>TrApp</code> and <code>TrFun</code> is ambiguous that can be solved with explicit quantification. Second, GHC can&#39;t know that kind <code>TypeRep :: k -&gt; *</code> is identical with <code>* -&gt; *</code>.</p><p>Kind equality extends the idea of kind polymorphism by declaring that types and kinds are indeed one and the same. Nothing within GHC distinguishes between types and kinds. Another way of thinking about this is that the type <code>Bool</code> and the “promoted kind” <code>&#39;Bool</code> are actually identical. </p><blockquote><p>One simplification allowed by combining types and kinds is that the type of <code>Type</code> is just <code>Type</code>. It is true that the <code>Type :: Type</code> axiom can lead to non-termination, but this is not a problem in GHC, as we already have other means of non-terminating programs in both types and expressions. This decision (among many, many others) does mean that despite the expressiveness of GHC’s type system, a “proof” you write in Haskell is not an irrefutable mathematical proof. GHC promises only partial correctness, that if your programs compile and run to completion, their results indeed have the types assigned. It makes no claim about programs that do not finish in a finite amount of time.
<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overview-of-type-in-type">GHC User&#39;s Guide</a></p></blockquote><p>To enable <code>(* ::*)</code> axiom, you have to enable <code>TypeInType</code> extension, which is a deprecated alias of <code>PolyKinds</code>, <code>DataKinds</code> and <code>KindSignatures</code>. Its functionality has been integrated into these other extensions. With this extension, GHC can know that <code>k ~ *</code>, and the code can compile.</p><pre class="code" data-lang="haskell"><code>data TypeRep (a :: k) where<br/>  TrTyCon :: !Fingerprint -&gt; TyCon -&gt; TypeRep k -&gt; TypeRep (a :: k)<br/>  TrApp   :: forall k1 k2 (a :: k1 -&gt; k2) (b :: k1). <br/>          !Fingerprint <br/>          -&gt; TypeRep (a :: k1 -&gt; k2)<br/>          -&gt; TypeRep (b :: k1)<br/>          -&gt; TypeRep (a b)<br/>  TrFun   :: forall (r1 :: RuntimeRep) (r2 :: RuntimeRep)<br/>                     (a :: TYPE r1) (b :: TYPE r2).<br/>          !Fingerprint <br/>          -&gt; TypeRep a<br/>          -&gt; TypeRep b<br/>          -&gt; TypeRep (a -&gt; b)</code></pre><h3 id="Levity_Polymorphism">Levity Polymorphism</h3><p>You may notice, there are <code>RuntimeRep</code> and <code>TYPE</code> kind signatures in TrFun constructor. They relates to Levity Polymorphism, which is implemented in GHC version 8.0.1, released early 2016.</p><p>In brief, most of types we use everyday (Int, Bool, AST, ...) are boxed value, which is represented by a pointer into the heap. The main advantage of boxed types are supporting polymorphism. The disadvantage is slow performance. Most polymorphic languages also support some form of unboxed primitive values that are represented not by a pointer but by the value itself. In Haskell, unboxed types are denoted with <code>MagicHash</code> suffix.</p><pre class="code" data-lang="haskell"><code>{-# LANGUAGE MagicHash #-}<br/><br/>f :: Int# -&gt; Int#</code></pre><p>Haskell also categorizes types into <code>lifted</code>, and <code>unlifted</code>. Lifted types is one that is lazy. It is considered <code>lifted</code> because it has one extra element beyond the usual ones, representing a non-terminating computation. For example, Haskell’s <code>Bool</code> type is lifted, meaning that three <code>Bool</code>s are possible: <code>True</code>, <code>False</code> ,and <code>⊥</code>. An <code>unlifted</code> type, on the other hand, is strict. The element <code>⊥</code> does not exist in an unlifted type.</p><p>Because Haskell represents lazy computation as thunks at runtime, all lifted types must also be boxed. However, it is possible to have boxed, unlifted types.</p><ul><li>Lifted - Boxed: <code>Int</code>, <code>Bool</code>,...</li><li>Unlifted - Boxed: <code>ByteArray#</code></li><li>Unlifted - Unboxed: <code>Int#</code>, <code>Bool#</code></li></ul><p>Given these unboxed values, the boxed versions can be defined in Haskell itself; GHC does not treat them specially. For example:</p><pre class="code" data-lang="haskell"><code>data Char = C# Char#<br/>data Int = I# Int#<br/><br/>plusInt :: Int -&gt; Int -&gt; Int <br/>plusInt (I# i1) (I# i2) = I# (i1 +# i2)</code></pre><p>Here <code>Int</code> is an ordinary algebraic data type, with one data constructor <code>I#</code>, that has one field of type <code>Int#</code>. The function <code>plusInt</code> simply
pattern matches on its arguments, fetches their contents (<code>i1</code> and <code>i2</code>, both of type <code>Int#</code>), adds them using <code>(+#)</code>, and boxes the result with <code>I#</code>.</p><p>The issue is, like many other compilers for a polymorphic language, GHC assumes that a value of polymorphic type, such as <code>x :: a</code> s represented uniformly by a heap pointer, or lifted type. The compiler adopts <code>The Instantiation Principle</code>: </p><blockquote><p>You cannot instantiate a polymorphic type variable with an unlifted type.</p></blockquote><p>That is tiresome for programmers, but in return they get solid performance guarantees.</p><p>How can the compiler implement the instantiation principle? For example, how does it even know if a type is unlifted? By kinds, much the same way that terms are classified by types. <code>Type</code>, or <code>*</code> kind which we use every day is lifted. In contrast, <code>#</code> is a new kind that classifies unlifted types, e.g: <code>Int#</code>, <code>Bool#</code>.</p><p>In default, polymorphism functions assume kind of parameters is <code>Type</code>. If we attempt to instantiate it at type <code>Float# :: #</code>, we will get a
kind error because <code>Type</code> and <code>#</code> are different kinds. The function arrow type <code>(-&gt;)</code> is the same. It is just a binary type constructor with kind:</p><pre class="code" data-lang="haskell"><code>(-&gt;) :: Type -&gt; Type -&gt; Type</code></pre><p>But now we have a serious problem: a function over unlifted types, such as <code>sumTo# :: Int# -&gt; Int# -&gt; Int#</code>, becomes ill-kinded!. </p><p>For many years its “solution” was to support a sub-kinding relation. That is, GHC had a kind <code>OpenKind</code>, a super-kind of both <code>Type</code> and <code>#</code>. We could then say that:</p><pre class="code" data-lang="haskell"><code>(-&gt;) :: OpenKind -&gt; OpenKind -&gt; Type </code></pre><p>However, there are drawbacks. The combination of type inference, polymorphism, and sub-typing, is problematic. And indeed GHC’s implementation of type inference was riddled with awkward and unprincipled special cases caused by sub-kinding. Moreover, The kind <code>OpenKind</code> would embarrassingly appear in error messages.</p><p>Levity polymorphism bring new idea: replace sub-kinding with kind polymorphism. New primitive type-level constant, <code>TYPE :: RuntimeRep -&gt; Type</code> is introduced with the following supporting definitions:</p><pre class="code" data-lang="haskell"><code>data RuntimeRep = VecRep VecCount VecElem   -- ^ a SIMD vector type<br/>                | TupleRep [RuntimeRep]     -- ^ An unboxed tuple of the given reps<br/>                | SumRep [RuntimeRep]       -- ^ An unboxed sum of the given reps<br/>                | LiftedRep       -- ^ lifted; represented by a pointer<br/>                | UnliftedRep     -- ^ unlifted; represented by a pointer<br/>                | IntRep          -- ^ signed, word-sized value<br/>                | WordRep         -- ^ unsigned, word-sized value<br/>                | Int64Rep        -- ^ signed, 64-bit value (on 32-bit only)<br/>                | Word64Rep       -- ^ unsigned, 64-bit value (on 32-bit only)<br/>                | AddrRep         -- ^ A pointer, but &#x2F;not&#x2F; to a Haskell value<br/>                | FloatRep        -- ^ a 32-bit floating point number<br/>                | DoubleRep       -- ^ a 64-bit floating point number<br/><br/>type Type = TYPE &#39;LiftedRep </code></pre><p>RuntimeRep is a type that describes the runtime representation of values of a type. <code>Type</code>, the kind that classifies the types of values, was
previously treated as primitive, but now becomes a synonym for <code>TYPE Lifted</code>, where <code>Lifted :: RuntimeRep</code>. It is easiest to see how these
definitions work using examples:</p><pre class="code" data-lang="haskell"><code>Int :: Type<br/>Int :: TYPE `LiftedRep -- Expanding Type<br/>Int# :: TYPE &#39;IntRep<br/>Float# :: TYPE &#39;FloatRep<br/>(Int, Bool) :: Type<br/>Maybe Int :: Type<br/>Maybe :: Type -&gt; Type</code></pre><p>Any type that classifies values, whether boxed or unboxed, lifted or unlifted, has kind <code>TYPE r</code> for some <code>r :: RuntimeRep</code>. The type
<code>RuntimeRep</code> tells us the runtime representation of values of that type. This datatype encodes the choice of runtime value.</p><p>We can now give proper types to <code>(-&gt;)</code>, same as <code>TrFun</code>. This enables polymorphism for both lifted and unlifted types.</p><pre class="code" data-lang="haskell"><code>import GHC.Exts<br/><br/>(-&gt;) :: forall (r1 :: RuntimeRep) (r2 :: RuntimeRep)<br/>      . TYPE r1 -&gt; TYPE r2 -&gt; Type</code></pre><p><strong>Note</strong>: Unboxed and Levity Polymorphism types are imported in <code>GHC.Exts</code> module.</p><p>If you are more curious about Levity polymorphism, let&#39;s take a look at <a href="https://cs.brynmawr.edu/~rae/papers/2017/levity/levity-extended.pdf">original paper</a>.</p><h3 id="Compare_TypeReps">Compare TypeReps</h3><p>It is sometimes necessary to use type representations in the key of a map. For example, <a href="http://hackage.haskell.org/package/shake-0.17.3/docs/Development-Shake.html">Shake</a> uses a map keyed on type representations to look up class instances (dictionaries) at runtime; these instances define class operations for the types of data stored in a collection of <code>Dynamic</code>s. Storing the class operations once per type, instead of with each <code>Dynamic</code> package, is much more efficient.</p><p>More specifically, we would like to implement the following interface:</p><pre class="code" data-lang="haskell"><code>data TyMap <br/>empty :: TyMap <br/>insert :: Typeable a =&gt; a -&gt; TyMap -&gt; TyMap<br/>lookup :: Typeable a =&gt; TyMap -&gt; Maybe a</code></pre><p>But how should we implement these type-indexed maps? One option is to use <code>HashMap</code>. We can define the typed-map as a map between the type representation and a dynamic value.</p><pre class="code" data-lang="haskell"><code>data SomeTypeRep where<br/>  SomeTypeRep :: forall k (a :: k). !(TypeRep a) -&gt; SomeTypeRep<br/><br/>type TyMap = HashMap SomeTypeRep Dynamic</code></pre><p>Notice that we must wrap the <code>TypeRep</code> key in an existential <code>SomeTypeRep</code>, otherwise all the keys would be for the same type, which would rather defeat the purpose! The <code>insert</code> and <code>lookup</code> functions can then use <code>toDynamic</code> and <code>fromDynamic</code> to ensure that the right type of value is stored with each key.</p><pre class="code" data-lang="haskell"><code>import Data.HashMap.Strict as Map<br/><br/>insert :: Typeable a =&gt; a -&gt; TyMap -&gt; TyMap <br/>insert x = Map.insert (SomeTypeRep (typeRep :: TypeRep a)) (toDynamic x)<br/><br/>lookup :: Typeable a =&gt; TyMap -&gt; Maybe a<br/>lookup = fromDynamic &lt;=&lt; Map.lookup (SomeTypeRep (typeRep :: TypeRep a))</code></pre><p>Because <code>Map</code> family uses balanced binary trees to achieve efficient lookup, <code>SomeTypeRep</code> must be an instance of <code>Ord</code>. This is straightforward, since <code>TypeRep</code> use fingerprint for unique hash, it can be compared too. </p><pre class="code" data-lang="haskell"><code>instance Ord SomeTypeRep where<br/>  SomeTypeRep a `compare` SomeTypeRep b =<br/>    typeRepFingerprint a `compare` typeRepFingerprint b </code></pre><p>Notice that we cannot make an instance for <code>Ord (TypeRep a)</code>: if we compare two values both of type <code>TypeRep t</code>, following the signature of
compare, they should always be equal!</p><h3 id="Other_Changes">Other Changes</h3><ul><li>Type-indexed type representation interface is in <code>Type.Reflection</code> module.<code>Data.Typeable</code> provides type representations which are qualified over this index, providing an interface very similar to the <code>Typeable</code> notion seen in previous releases for backward compatibility.</li><li><code>Data.Typeable.TypeRep</code> and <code>Type.Reflection.TypeRep</code> are different. <code>Data.Typeable.TypeRep</code> is alias of <code>SomeTypeRep</code> </li><li><code>TypeRep</code> definition is replaced with record, to easier to extend parameters</li></ul><pre class="code" data-lang="haskell"><code>data TypeRep (a :: k) where<br/>    TrType :: TypeRep Type<br/>    TrTyCon :: { trTyConFingerprint :: {-# UNPACK #-} !Fingerprint<br/>               , trTyCon :: !TyCon<br/>               , trKindVars :: [SomeTypeRep]<br/>               , trTyConKind :: !(TypeRep k) <br/>               }  <br/>            -&gt; TypeRep (a :: k)<br/>            <br/>    TrApp   :: forall k1 k2 (a :: k1 -&gt; k2) (b :: k1).<br/>               { <br/>                 trAppFingerprint :: {-# UNPACK #-} !Fingerprint<br/>               , trAppFun :: !(TypeRep (a :: k1 -&gt; k2))<br/>               , trAppArg :: !(TypeRep (b :: k1))<br/>               , trAppKind :: !(TypeRep k2) }<br/>            -&gt; TypeRep (a b)<br/><br/>    TrFun   :: forall (r1 :: RuntimeRep) (r2 :: RuntimeRep)<br/>                      (a :: TYPE r1) (b :: TYPE r2).<br/>               {<br/>                 trFunFingerprint :: {-# UNPACK #-} !Fingerprint<br/>               , trFunArg :: !(TypeRep a)<br/>               , trFunRes :: !(TypeRep b) }<br/>            -&gt; TypeRep (a -&gt; b)</code></pre><ul><li>The kind of the TypeRep in each <code>TrTyCon</code> and <code>TrApp</code> constructor is cached. This is necessary to ensure that typeRepKind (which is used, at least, in deserialization and dynApply) is cheap, because calculating the kind of type constructor and nested type applications is pricy,</li><li>We need to be able to represent <code>TypeRep Type</code>. This is a bit tricky because <code>typeRepKind (typeRep @Type) = typeRep @Type</code>, so if we actually cache the <code>TypeRep</code> of the kind of <code>Type</code>, we will have a loop. One simple way to do this is to make the cached kind fields lazy and allow <code>TypeRep Type</code> to be cyclical.</li></ul><h2 id="Limitation_and_unexplored_future">Limitation and unexplored future</h2><p>Our interface does not support representations of polymorphic types, such as <code>TypeRep (∀ a. a -&gt; a)</code>. Although plausible, supporting those in our setting brings in a whole new range of design decisions that are as of yet unexplored (e.g. higher-order representations vs. de-Bruijn?). Furthermore, it requires the language to support impredicative polymorphism (the ability to instantiate quantified variables with polymorphic types, for instance the <code>a</code> variable in <code>TypeRep a</code> or <code>Typeable a</code>), which GHC currently does not. Finally, representations of polymorphic types have implications on semantics and possibly parametricity.</p><p>Similarly, constructors with polymorphic kinds would require impredicative kind polymorphism. A representation of type <code>TypeRep (Proxy :: ∀ kp. kp -&gt; *)</code> would require the kind parameter <code>k</code> of <code>TypeRep (a :: k)</code> to be instantiated to the polymorphic kind <code>∀ kp. kp -&gt; *</code>. Type inference for impredicative kind polymorphism is no easier than for impredicative type polymorphism and we have thus excluded this possibility.</p><h2 id="Summary_">Summary </h2><p><code>Typeable</code> take a long journey for definition, design, refactor and redesign, from runtime term level to type-safe. However, the journey doesn&#39;t stop here. GHC is still growing, better and safer, with innovation and contribution of brilliant researchers. It motivates us to study and do great software and bring toward the industry.</p><h2 id="Acknowledgment">Acknowledgment</h2><p>Thanks to Richard A. Eisenberg and his team for great research and contribution. This post take many reference in their papers. </p><h2 id="Appendix">Appendix</h2><ul><li>The complete code in &quot;A reflection on types&quot; paper: <a href="https://gist.github.com/hgiasac/1072f9f97b57732ac0040c122ce7f41b">link</a></li><li>Homogeneous equality ~ Type equality: (<code>a :~: b</code>)</li><li>Heterogeneous equality ~ Kind equality: (<code>a :~~: b</code>)</li><li>Universal quantification: <code>forall a. a -&gt; a</code></li><li>Existentially quantified type: <code>forall a. Show a =&gt; a -&gt; String</code></li></ul><h2 id="References">References</h2><ul><li><a href="http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-47.pdf">Dynamic Typing in a Statically Typed Language - Martin Abadi, Luca Cardelli, Benjamin Pierce, Gordon Plotkin (1989)</a></li><li><a href="https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/kind-polymorphism-and-promotion.html">Kind polymorphism - GHC Language Features. Chapter 7</a></li><li><a href="https://www.microsoft.com/en-us/research/publication/scrap-your-boilerplate-a-practical-approach-to-generic-programming">Scrap your boilerplate: a practical approach to generic programming - Ralf Lämmel, Simon Peyton Jones (January 2003)</a></li><li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.19.7113&rep=rep1&type=pdf">A Lightweight Implementation of Generics and Dynamics - James Cheney, Ralf Hinze (October 3, 2002)</a></li><li><a href="http://dreixel.net/research/pdf/ghp.pdf">Giving Haskell a Promotion - Brent A. Yorgey, Stephanie Weirich, Julien Cretin, Simon Peyton Jones, Dimitrios Vytiniotis, Jose Pedro Magalhaes (2012)</a></li><li><a href="https://stackoverflow.com/questions/37261593/who-invented-proxy-passing-and-when">Who invented proxy passing and when? - Stackoverflow</a></li><li><a href="https://stackoverflow.com/a/35320729">What is Levity polymorphism - Stackoverflow</a> </li><li><a href="https://cs.brynmawr.edu/~rae/papers/2017/levity/levity-extended.pdf">Levity polymorphism (extended version) - Richard A. Eisenberg, Simon Peyton Jones (2017)</a></li><li><a href="https://ghc.haskell.org/trac/ghc/wiki/TypeLevelReasoning">TypeLevelReasoning Proposal - Richard A. Eisenberg</a></li><li><a href="https://cs.brynmawr.edu/~rae/papers/2015/equalities/equalities.pdf">An overabundance of equality: Implementing kind equalities into Haskell - Richard A. Eisenberg (September 22, 2015)</a></li><li><a href="https://www.microsoft.com/en-us/research/publication/typed-reflection-in-haskell">Typed reflection in Haskell - Simon Peyton Jones, Stephanie Weirich, Richard A. Eisenberg, Dimitrios Vytiniotis - Proc Philip Wadler&#39;s 60th birthday Festschrift, Edinburgh, April 2016</a></li><li><a href="https://ghc.haskell.org/trac/ghc/wiki/Typeable">Safer and more expressive type representations - Haskell Trac Wiki</a></li><li><a href="https://ghc.haskell.org/trac/ghc/wiki/DistributedHaskell">Types-safe Distributed Haskell - Haskell Trac Wiki</a></li><li><a href="https://cs.brynmawr.edu/~rae/papers/2013/fckinds/fckinds.pdf">System FC with Explicit Kind Equality</a></li><li><a href="https://www.microsoft.com/en-us/research/publication/typed-reflection-in-haskell">A reflection on types</a></li><li><a href="https://stackoverflow.com/questions/993112/what-does-the-exclamation-mark-mean-in-a-haskell-declaration">What does the exclamation mark mean in a Haskell declaration? - Stackoverflow</a></li><li><a href="http://git.haskell.org">Haskell Git Repository</a></li><li><a href="https://www.microsoft.com/en-us/research/publication/towards-haskell-cloud/">Towards Haskell in the Cloud - Jeff Epstein, Andrew Black, Simon Peyton Jones (September 2011)</a></li><li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overview-of-type-in-type">GHC User&#39;s Guide</a></li></ul></article></div></div></div></section><footer><div class="wrapper"><div class="container grid-lg"><hr/><div class="text-center"><a class="secondary" href="https://github.com/hgiasac"><i class="fa fa-github fa-2x"> </i></a><a class="secondary" href="https://www.linkedin.com/in/toan-nguyen-83295527/"><i class="fa fa-linkedin fa-2x"> </i></a><a class="secondary" href="https://stackoverflow.com/users/4230985/hgiasac"><i class="fa fa-stack-overflow fa-2x"> </i></a></div><div class="text-center mt-2">© Toan Nguyen 2017-2020</div></div></div></footer></body></html>