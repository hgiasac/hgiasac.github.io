<html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Are Promises Monads Functor or Applicative (2017-20-12)</title><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,500"/><link rel="stylesheet" href="/assets/main.min.css"/><link rel="stylesheet" href="https://maxcdn.icons8.com/fonts/line-awesome/1.1/css/line-awesome-font-awesome.min.css"/></head><meta name="description" content="If we have ever programmed with JavaScript, we all know about Promises. The Promise object abstracts the future value of an asynchronous operation. It can be the eventual completion (or failure) of asynchronous result"/><body><header><div class="container grid-lg"><nav class="horizontal main-nav"><ul><li><a href="/">Home</a></li><li><a href="/works.html">Works</a></li><li><a href="/posts">Posts</a></li><li><a href="/about.html">About</a></li><li><a href="https://www.visualcv.com/toan-nguyen">CV</a></li></ul></nav></div></header><section class="section"><div id="main"><div class="wrapper"><div class="container grid-lg"><hr class="mt-2"/><article class="article"><h1 id="Are_Promises_Monads_Functor_or_Applicative">Are Promises Monads, Functor or Applicative</h1><p>If we have ever programmed with JavaScript, we all know about Promises. The Promise object abstracts the future value of an asynchronous operation. It can be the eventual completion (or failure) of asynchronous result</p><p>Promises is very popular today. Many imperative programing languages adapt it. However, when we learn about functional programming, especially Haskell, sometimes we wonder that Promises are monads?</p><p>Haskell is near to mathematic. Each type class is a mathematic object. If we want to know a instance is a type of Functor, Monad or Applicative,we need to prove if the target is satisfy the laws. </p><p>Because each language has another mechanism to implement Promises, Promises can be different. In first section, I will talk about JavaScript. </p><h2 id="Laws">Laws</h2><p>Before go to the detail, let&#39;s a look at those laws. Note, p ≡ q simply means that you can replace p with q and vice-versa, and the behavior of your program will not change: p and q are equivalent.</p><h3 id="Functor">Functor</h3><pre class="code" data-lang="haskell"><code>fmap id ≡ id -- Identity law<br/><br/>fmap (g . f) ≡ fmap g . fmap f -- Associativity<br/></code></pre><h3 id="Monad">Monad</h3><pre class="code" data-lang="haskell"><code>return a &gt;&gt;= f ≡ f a -- Left identity<br/><br/>m &gt;&gt;= return ≡ m -- Right identity<br/><br/>(m &gt;&gt;= f) &gt;&gt;= g ≡     m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g) -- Associativity</code></pre><h2 id="JavaScript">JavaScript</h2><h3 id="Are_Promises_Functor_">Are Promises Functor? </h3><p>The analogous Promise function for <code>fmap</code> is <code>then</code>. The constructor is <code>Promise.resolve</code>.</p><pre class="code" data-lang="javascript"><code>&#x2F;&#x2F; id :: a -&gt; a<br/>const id = (a) =&gt; a<br/><br/>&#x2F;&#x2F; fmap id ≡ id -- functor law<br/>const lp = Promise.resolve(1).then(id)<br/>const rp = id(Promise.resolve(1))<br/><br/>Promise.all([lp, rp]).then(([a, b]) =&gt; console.log(a === b))<br/>&#x2F;&#x2F; true<br/></code></pre><p>Promise seems satisfy Identity law. We can go next with Associativity law.</p><pre class="code" data-lang="javascript"><code>&#x2F;&#x2F; fmap (g . f) ≡ fmap g . fmap f -- Associativity<br/>const f = (a) =&gt; a * 2;<br/>const g = (a) =&gt; a * 3;<br/><br/>Promise.all([<br/>  Promise.resolve(1).then(f).then(g),<br/>  Promise.resolve(1).then(a =&gt; g(f(a))),<br/>]);<br/>&#x2F;&#x2F; true</code></pre><p>Hooray. The result is same as the expectation. However:</p><pre class="code" data-lang="javascript"><code>&#x2F;&#x2F; fmap (g . f) ≡ fmap g . fmap f -- Associativity<br/>const f = (a) =&gt; Promise.resolve(a * 2);<br/>const g = (pa) =&gt; pa.then((b) =&gt; b * 3);<br/><br/>Promise.resolve(1).then(f).then(g),<br/>&#x2F;&#x2F; TypeError: pa.then is not a function</code></pre><p>If <code>f</code> return a Promise, the law will be violated. The value that gets passed to f is implicitly unwrapped, causes TypeError</p><p><strong>Answer</strong>: <strong>No</strong></p><h3 id="Are_Promises_Monads">Are Promises Monads?</h3><p>The analogous Promise function for <code>bind</code> is <code>then</code>. It is same as <code>fmap</code>, right? In my option, because JavaScript is dynamic language, to make developers easier to learn, and not confuse about result type, the internal async promises inside <code>then</code> is implicitly unwrapped. The analogous function for <code>return</code> is <code>Promise.resolve</code>.</p><pre class="code" data-lang="javascript"><code>&#x2F;&#x2F; return a &gt;&gt;= f ≡ f a -- Left identity<br/>const f = (a) =&gt; Promise.resolve(a * 2);<br/>const lp = Promise.resolve(1).then(f);<br/>const rp = f(1)<br/><br/>Promise.all([lp, rp]).then(([a, b]) =&gt; console.log(a === b));<br/></code></pre><p>It upholds the law. However, if <code>a</code> is a Promise, the law is violated.</p><pre class="code" data-lang="javascript"><code>const f = (m) =&gt; m.then((a) =&gt; a * 2);<br/><br/>Promise.resolve(Promise.resolve(1)).then(f).then(console.log);<br/>&#x2F;&#x2F; TypeError: m.then is not a function</code></pre><p>Because Promise implicitly unwrapped the Promise inside, the value in <code>then</code> is no longer Promise. The <code>TypeError</code> is raised. Second:</p><pre class="code" data-lang="javascript"><code>&#x2F;&#x2F; m &gt;&gt;= return ≡ m -- Right identity<br/><br/>Promise.all([<br/>  Promise.resolve(1).then((a) =&gt; Promise.resolve(a)),<br/>  Promise.resolve(1)<br/>]).then(([a, b]) =&gt; console.log(a === b));<br/>&#x2F;&#x2F; true</code></pre><p>Right identity is satisfied, too. Note, we can&#39;t use free point style <code>Promise.resolve(1).then(Promise.resolve)</code>. <code>TypeError: PromiseResolve called on non-object</code> will be raised.</p><p>Finally, the Associativity law:</p><pre class="code" data-lang="javascript"><code><br/>&#x2F;&#x2F;(m &gt;&gt;= f) &gt;&gt;= g ≡	 m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g) -- Associativity<br/>const f = x =&gt; Promise.resolve(x * 2);<br/>const g = y =&gt; Promise.resolve(y * 3);<br/><br/>Promise.all([<br/>  Promise.resolve(1).then(f).then(g),<br/>  Promise.resolve(1).then((x) =&gt; f(x).then(g))<br/>]).then(([a, b]) =&gt; console.log(a === b));</code></pre><p>The law is satisfied. However, it is also violated if the input value is a Promise</p><pre class="code" data-lang="javascript"><code><br/>&#x2F;&#x2F;(m &gt;&gt;= f) &gt;&gt;= g ≡	 m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g) -- Associativity<br/><br/>const a = Promise.resolve(1);<br/>const f = p =&gt; p.then(x =&gt; x * 2);<br/>const g = y =&gt; Promise.resolve(y * 3);<br/><br/>Promise.all([<br/>  Promise.resolve(a).then(f).then(g),<br/>  Promise.resolve(a).then((x) =&gt; f(x).then(g))<br/>]).then(([a, b]) =&gt; console.log(a === b));<br/>&#x2F;&#x2F; TypeError: p.then is not a function</code></pre><p><strong>Answer</strong>: <strong>No</strong></p><h3 id="So_how_about_Applicative">So, how about Applicative?</h3><p>Because Applicative class is extended from Functor class, so if Promises don&#39;t satisfy Functor class, Applicative don&#39;t satisfy too.</p><pre class="code" data-lang="haskell"><code>class (Functor f) =&gt; Applicative f where<br/>  pure :: a -&gt; f a<br/>  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</code></pre><p><strong>Answer</strong>: <strong>No</strong></p><h2 id="Promises_in_Scala">Promises in Scala</h2><p>In Scala, the author divide this asynchronous specification into 2 terms: <code>Future</code> and <code>Promise</code>, and we usually call it <code>Future</code>. In brief:</p><blockquote><p>A future is a placeholder object for a result that does not yet exist. A promise is a writable, single-assignment container, which completes a future. Promises can complete the future with a result to indicate success, or with an exception to indicate failure.
<a href="https://docs.scala-lang.org/overviews/core/futures.html">Futures and Promises</a></p></blockquote><p>Scala language is a combination of OOP and common function programming with static types. Of course it is much better than JavaScript too. With <code>map</code> and <code>flatMap</code>, it remove the confusion of JavaScript Promise </p><pre class="code" data-lang="scala"><code>val fa = Future { 1 }<br/><br/>fa map { a =&gt; a * 2 }<br/>&#x2F;&#x2F; scala.concurrent.Future[Int]<br/>fa map { a =&gt; Future { a * 2 } }<br/>&#x2F;&#x2F; scala.concurrent.Future[scala.concurrent.Future[Int]]<br/><br/>fa flatMap { a =&gt; Future { a * 2 } }<br/>&#x2F;&#x2F; scala.concurrent.Future[Int]<br/></code></pre><p><strong>Answer</strong>: <strong>Yes All</strong></p><h2 id="References">References</h2><ol><li><a href="http://dist-prog-book.com/chapter/2/futures.html">Futures and Promises</a> - Kisalaya Prasad, Avanti Patil, and Heather Miller</li><li><a href="https://wiki.haskell.org/Monad_laws">Monad Laws</a></li><li><a href="https://wiki.haskell.org/Functor">Functor</a></li><li><a href="https://en.wikibooks.org/wiki/Haskell/Applicative_functors">Applicative Functors</a></li></ol></article></div></div></div></section><footer><div class="wrapper"><div class="container grid-lg"><hr/><div class="text-center"><a class="secondary" href="https://github.com/hgiasac"><i class="fa fa-github fa-2x"> </i></a><a class="secondary" href="https://www.linkedin.com/in/toan-nguyen-83295527/"><i class="fa fa-linkedin fa-2x"> </i></a><a class="secondary" href="https://stackoverflow.com/users/4230985/hgiasac"><i class="fa fa-stack-overflow fa-2x"> </i></a></div><div class="text-center mt-2">© Toan Nguyen 2017-2019</div></div></div></footer></body></html>