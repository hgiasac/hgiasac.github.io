<html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>PureScript GADTs Alternatives - Recap (2018-12-18)</title><link rel="stylesheet" href="/assets/main.min.css"/><link rel="stylesheet" href="https://maxcdn.icons8.com/fonts/line-awesome/1.1/css/line-awesome-font-awesome.min.css"/></head><meta name="description" content="GADTs (&quot;Generalized Algebraic Data Types&quot;) provide an explicit instantiation of the ADT as the type instantiation of their return value. This gives you power to define type safe data structures with more advanced type behavior..."/><body><header><div class="container grid-lg"><nav class="horizontal main-nav"><ul><li><a href="/">Home</a></li><li><a href="/works.html">Works</a></li><li><a href="/posts">Posts</a></li><li><a href="/about.html">About</a></li><li><a href="https://www.visualcv.com/toan-nguyen">CV</a></li></ul></nav></div></header><section class="section"><div id="main"><div class="wrapper"><div class="container grid-lg"><hr class="mt-2"/><article class="article"><h1 id="PureScript_GADTs_Alternative_-_Recap">PureScript GADTs Alternative - Recap</h1><p>GADTs (&quot;Generalized Algebraic Data Types&quot;) provide an explicit instantiation of the ADT as the type instantiation of their return value. This gives you power to define type safe data structures with more advanced type behavior. Unfortunately, in the time of this post, latest version or PureScript (0.12) hasn&#39;t supported GADTs yet.</p><p>However, we can overcome the limit with alternative methods. This post is just a recap from what I researched.</p><h3 id="The_Problem_">The Problem </h3><p>With GADTs extension, we could write a little eDSL for arithmetic and comparison expressions something like this:</p><pre class="code" data-lang="haskell"><code>data Expr a where<br/>  Val :: Int -&gt; Expr Int<br/>  Add :: Expr Int -&gt; Expr Int -&gt; Expr Int<br/>  Mult :: Expr Int -&gt; Expr Int -&gt; Expr Int<br/>  Equal :: Expr Int -&gt; Expr Int -&gt; Expr Bool<br/>  Not :: Expr Bool -&gt; Expr Bool<br/><br/>eval :: Expr a -&gt; a<br/>eval (Val x) = x<br/>eval (Add x y) = eval x + eval y<br/>eval (Mult x y) = eval x * eval y<br/>eval (Equal x y) = eval x == eval y<br/>eval (Not x) = not (eval x)</code></pre><p>Without GADTs it seems like this eval function would be impossible to write, since we wouldn’t have the information to determine the result type that matching on a data constructor of a GADT gives us.</p><h2 id="Leibniz_equality">Leibniz equality</h2><blockquote><p>This is recap from <a href="http://code.slipthrough.net/2016/08/10/approximating-gadts-in-purescript/">Approximating GADTs in PureScript</a> </p></blockquote><blockquote><p>Two types are equal if they are equal in all contexts.</p></blockquote><h3 id="The_solution">The solution</h3><p>We can’t directly encode type equalities using the type system in PureScript, but we can take advantage of <a href="https://en.wikipedia.org/wiki/Identity_of_indiscernibles">“Leibniz equality”</a> and encode it in a value instead:</p><pre class="code" data-lang="purescript"><code>newtype Leibniz a b = Leibniz (forall f. f a -&gt; f b)<br/><br/>infix 4 type Leibniz as ~<br/><br/>symm :: forall a b. (a ~ b) -&gt; (b ~ a)<br/>symm = ...<br/><br/>coerce :: forall a b. (a ~ b) -&gt; a -&gt; b<br/>coerce = ...</code></pre><p><code>(a ~ b)</code> is a Leibniz value, with <code>a</code> is a variable that is identical with some type <code>b</code>. This allows us to <code>coerce</code> one type to another.</p><p>The <code>symm</code> function is used when we have a type equality that we need to “turn around” so that we can coerce in either direction based on a provided Leibniz value. This is possible thanks to the fact that equality relations are symmetric (for every a and b, if a = b then b = a), and is where the name <code>symm</code> comes from.</p><p>Go back to the example. In the GADT-defined Expr, the final part of the type annotation for each data constructor, ... -&gt; Expr SomeType, is essentially saying “a ~ SomeType for this constructor”. </p><p>When a constructor of a GADT is pattern-matched, the type-checker gains knowledge of this equality and then lets us return a value of the appropriate type, rather than being stuck with the rigid type variable a.</p><pre class="code" data-lang="purescript"><code>data Expr a<br/>  = Add (Expr Int) (Expr Int) (a ~ Int)<br/>  | Mult (Expr Int) (Expr Int) (a ~ Int)<br/>  | Equal (Expr Int) (Expr Int) (a ~ Boolean)<br/>  | Not (Expr Boolean) (a ~ Boolean)<br/>  | Val Int (a ~ Int)</code></pre><p>We can now write <code>eval</code> using the <code>coerce</code> function to safely cast the result type back to a in each case:</p><pre class="code" data-lang="purescript"><code>coerceSymm :: forall a b. (a ~ b) -&gt; b -&gt; a<br/>coerceSymm = coerce &lt;&lt;&lt; symm<br/><br/>eval :: forall a. Expr a -&gt; a<br/>eval (Val x proof) = coerceSymm proof x<br/>eval (Add x y proof) = coerceSymm proof (eval x + eval y)<br/>eval (Mult x y proof) = coerceSymm proof (eval x * eval y)<br/>eval (Equal x y proof) = coerceSymm proof (eval x == eval y)<br/>eval (Not x proof) = coerceSymm proof (not (eval x))</code></pre><p>The only thing we haven’t covered is how to actually construct a Leibniz value in the first place. What possible function could we provide that satisfies <code>forall f. f a -&gt; f b</code> where <code>a</code> equals <code>b</code>? The identity function! Leibniz also has a Category instance, so actually we can just use <code>identity</code> directly:</p><pre class="code" data-lang="purescript"><code>val :: Int -&gt; Expr Int<br/>val x = Val x identity<br/><br/>add :: Expr Int -&gt; Expr Int -&gt; Expr Int<br/>add x y = Add x y identity<br/><br/>mult :: Expr Int -&gt; Expr Int -&gt; Expr Int<br/>mult x y = Mult x y identity<br/><br/>equal :: Expr Int -&gt; Expr Int -&gt; Expr Boolean<br/>equal x y = Equal x y identity<br/><br/>not :: Expr Boolean -&gt; Expr Boolean<br/>not x = Not x identity</code></pre><p>And finally, we can run our original example cases again:</p><pre class="code" data-lang="purescript"><code>&gt; eval (not (equal (mult (val 10) (val 1)) (add (val 0) (val 1))))<br/>true</code></pre><h3 id="Limitations">Limitations</h3><p>As the title of original post, <a href="https://twitter.com/gb_r">Gary Burgess</a> called it <code>Approximating GADTs</code>. This method can&#39;t solve all cases, especially in more complicated eDSLs. For example in polymorphism rank N-type DSL:</p><pre class="code" data-lang="haskell"><code>data Expr a where<br/>    Val     :: Int                     -&gt; Expr Int<br/>    Lambda  :: (Expr a -&gt; Expr b)      -&gt; Expr (Expr a -&gt; Expr b)<br/>    Apply   :: Expr (Expr a -&gt; Expr b) -&gt; Expr a -&gt; Expr b<br/>    Add     :: Expr Int -&gt; Expr Int    -&gt; Expr Int</code></pre><p>Since PureScript doesn&#39;t support existential types in AST, this method is useless.</p><pre class="code" data-lang="purescript"><code>data ExprL a = Val Int (a ~ Int) <br/>              | Add (ExprL Int) (ExprL Int) (a ~ Int)<br/>              | Lambda (ExprL b -&gt; ExprL c) (a ~ (ExprL b -&gt; ExprL c)) -- can&#39;t define existential type<br/>              | Apply (forall b c. ExprL (ExprL b -&gt; ExprL c)) (forall b. ExprL b) (forall c. a ~ c) -- nope</code></pre><h2 id="Tagless_Final_comes_to_rescue">Tagless Final comes to rescue</h2><blockquote><p>In the final approach, object language terms are represented as expressions built from a small set of combinators, which are ordinary functions rather than data constructors. The values of these expressions give denotations of the corresponding object terms. An object term is hence represented not by its abstract syntax but by its denotation in a semantic domain. Abstracting over the domain gives us a family of interpretations.
<a href="http://okmij.org/ftp/tagless-final/course/lecture.pdf">Typed Tagless Final Interpreters - Oleg Kiselyov</a></p></blockquote><h3 id="The_solution">The solution</h3><p>In Tagless Final approach, instead of declaring AST data type directly, we use type class as a set of operations:</p><pre class="code" data-lang="purescript"><code>class LambdaSym repr where<br/>  val :: Int -&gt; repr Int<br/>  lambda :: forall a b. (repr a -&gt; repr b) -&gt; repr (a -&gt; b)<br/>  apply :: forall a b. repr (a -&gt; b) -&gt; repr a -&gt; repr b<br/>  add :: repr Int -&gt; repr Int -&gt; repr Int</code></pre><p>It accepts all interpreters that implement those operations</p><pre class="code" data-lang="purescript"><code>data R a = R a<br/><br/>eval :: forall a. R a -&gt; a<br/>eval (R a) = a<br/><br/>instance lambdaSymmR :: LambdaSym R where<br/>  val a = R a<br/>  lambda f = R (\a -&gt; unR $ f (R a))<br/>  apply (R f) (R a) = R (f a)<br/>  add (R x) (R y) = R $ x + y</code></pre><p>The syntax is similar to Leibniz approach </p><pre class="code" data-lang="purescript"><code>testR :: forall repr. LambdaSym repr =&gt; repr Int<br/>testR = apply (lambda (\x -&gt; add (val x) (val x))) (val 10)<br/><br/>result :: Int <br/>result = eval testR </code></pre><p>Tagless Final has more advantages than GADTs and Leibniz approaches:</p><ul><li>Flexible, easy to extend the language with new operations.</li><li>Easier to implement</li><li>Requires less boilerplate. </li><li>Combine different parts of the DSL very easily, without change the existed code</li></ul><pre class="code" data-lang="purescript"><code>class MultiplySymm repr where<br/>  mult :: repr Int -&gt; repr Int -&gt; repr Int <br/><br/>testR&#39; :: forall repr. LambdaSym repr =&gt; MultiplySymm repr =&gt; repr Int<br/>testR&#39; = apply (lambda (\x -&gt; mult x x)) (val 10)</code></pre><h3 id="Limitations">Limitations</h3><p>From what I researched, because Haskell hasn&#39;t supported impredicative polymorphism. That means that we can’t specialize an existing data type to hold a polymorphic value like this:</p><pre class="code" data-lang="haskell"><code>Maybe (LambdaSym repr =&gt; repr Int)</code></pre><p>Fortunately, PureScript support impredicative polymorphism. We no need to worry about it.</p><pre class="code" data-lang="purescript"><code>type L = forall repr. Maybe (LambdaSym repr =&gt; repr Int)<br/><br/>testR&#39;:: L<br/>testR&#39; = Nothing</code></pre><h2 id="Conclusion_">Conclusion </h2><p>Compared to Leibniz, or even GADTs, Tagless Final style has many advantage as well as easy to grasp. It is wide adoption in functional programming world. Tagless Final style is a good alternative to GADTs </p><h2 id="References">References</h2><ol><li><a href="http://code.slipthrough.net/2016/08/10/approximating-gadts-in-purescript/">Approximating GADTs in PureScript - Gary Burgess</a></li><li><a href="https://en.wikipedia.org/wiki/Identity_of_indiscernibles">Typed Tagless Final Interpreters - Oleg Kiselyov</a></li></ol></article></div></div></div></section><footer><div class="wrapper"><div class="container grid-lg"><hr/><div class="text-center"><a class="secondary" href="https://github.com/hgiasac"><i class="fa fa-github fa-2x"> </i></a><a class="secondary" href="https://www.linkedin.com/in/toan-nguyen-83295527/"><i class="fa fa-linkedin fa-2x"> </i></a><a class="secondary" href="https://stackoverflow.com/users/4230985/hgiasac"><i class="fa fa-stack-overflow fa-2x"> </i></a></div><div class="text-center mt-2">© Toan Nguyen 2017-2019</div></div></div></footer></body></html>