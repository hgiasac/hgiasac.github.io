<html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Tuning-Hasura-at-Scale (2020-05-15)</title><meta property="og:title" content="Tuning-Hasura-at-Scale (2020-05-15)"/><meta property="twitter:title" content="Tuning-Hasura-at-Scale (2020-05-15)"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,500"/><link rel="stylesheet" href="/assets/main.min.css"/><link rel="stylesheet" href="https://maxcdn.icons8.com/fonts/line-awesome/1.1/css/line-awesome-font-awesome.min.css"/></head><meta name="description" content="PostgreSQL&#39;s basic configuration is tuned for wide compatibility rather than performance. The default parameters are very undersized for your system. You can read more detail of configuration settings at PostgreSQL Wiki. There are also config generator tools can help us."/><meta property="og:description" content="PostgreSQL&#39;s basic configuration is tuned for wide compatibility rather than performance. The default parameters are very undersized for your system. You can read more detail of configuration settings at PostgreSQL Wiki. There are also config generator tools can help us."/><meta property="twitter:description" content="PostgreSQL&#39;s basic configuration is tuned for wide compatibility rather than performance. The default parameters are very undersized for your system. You can read more detail of configuration settings at PostgreSQL Wiki. There are also config generator tools can help us."/><body><header><div class="container grid-lg"><nav class="horizontal main-nav"><ul><li><a href="/">Home</a></li><li><a href="/works.html">Works</a></li><li><a href="/posts">Posts</a></li><li><a href="/about.html">About</a></li><li><a href="https://www.visualcv.com/toan-nguyen">CV</a></li></ul></nav></div></header><section class="section"><div id="main"><div class="wrapper"><div class="container grid-lg"><hr class="mt-2"/><article class="article"><h1 id="Tune_Hasura_Performance_">Tune Hasura Performance </h1><ul><li><a href="#tune-hasura-performance">Tune Hasura Performance</a><ul><li><a href="#configuration-and-deployment">Configuration and Deployment</a><ul><li><a href="#tweak-postgres-configuration">Tweak Postgres configuration</a></li><li><a href="#hasura-configuration">Hasura configuration</a><ul><li><a href="#hasura-graphql-pg-connections">HASURA GRAPHQL PG CONNECTIONS</a></li><li><a href="#hasura-graphql-connections-per-read-replica">HASURA GRAPHQL CONNECTIONS PER READ REPLICA</a></li><li><a href="#hasura-graphql-live-queries-multiplexed-refetch-interval">HASURA GRAPHQL LIVE QUERIES MULTIPLEXED REFETCH INTERVAL</a></li><li><a href="#hasura-graphql-live-queries-multiplexed-batch-size">HASURA GRAPHQL LIVE QUERIES MULTIPLEXED BATCH SIZE</a></li></ul></li><li><a href="#scale-hasura">Scale Hasura</a></li><li><a href="#scale-postgresql-servers">Scale PostgreSQL Servers</a></li><li><a href="#monitoring">Monitoring</a><ul><li><a href="#hasura">Hasura</a></li><li><a href="#server--postgres">Server + Postgres</a></li></ul></li></ul></li><li><a href="#software-architecture-and-best-practices">Software Architecture and Best Practices</a><ul><li><a href="#hasura-as-data-service">Hasura as Data service</a><ul><li><a href="#connection-pooler">Connection Pooler</a></li><li><a href="#load-balancer-pro">Load Balancer (Pro)</a></li></ul></li><li><a href="#understand-your-data">Understand your data</a></li><li><a href="#microservices">Microservices</a></li><li><a href="#postgres-ecosystem">Postgres ecosystem</a></li></ul></li><li><a href="#summary">Summary</a></li></ul></li></ul><h2 id="Configuration_and_Deployment">Configuration and Deployment</h2><h3 id="Tweak_Postgres_configuration">Tweak Postgres configuration</h3><p>PostgreSQL&#39;s basic configuration is tuned for wide compatibility rather than performance. The default parameters are very undersized for your system. You can read more detail of configuration settings at PostgreSQL Wiki. There are also config generator tools can help us.</p><ul><li><a href="https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server">Tuning Your PostgreSQL Server</a></li><li>Config generator: <a href="https://pgtune.leopard.in.ua">https:&#x2F;&#x2F;pgtune.leopard.in.ua</a></li></ul><h3 id="Hasura_configuration">Hasura configuration</h3><h4 id="HASURA_GRAPHQL_PG_CONNECTIONS">HASURA GRAPHQL PG CONNECTIONS</h4><ul><li>Environment variable: <code>HASURA_GRAPHQL_PG_CONNECTIONS</code></li><li>Minimum <strong>2</strong> connections </li><li>Default value: <strong>50</strong></li><li>Max connections: = Max connections of Postgres - 5 (keep free connections for another services, e.g PGAdmin, metrics tools)</li></ul><p>However, how many connections is best settings? Of course, it depends on Postgres server&#39;s hardware specification. Moreover, too many connections don&#39;t mean query performance will be highest. There are many great articles that analyze deeper on this:</p><ul><li><a href="https://brandur.org/postgres-connections">https:&#x2F;&#x2F;brandur.org&#x2F;postgres-connections</a></li><li><a href="https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing">https:&#x2F;&#x2F;github.com&#x2F;brettwooldridge&#x2F;HikariCP&#x2F;wiki&#x2F;About-Pool-Sizing</a></li></ul><p>There isn&#39;t silver bullet for all server specs. You developer has to test and benchmark carefully for final result. However, at a start point, you can estimate with this formula, then test around this value:</p><pre class="code" data-lang=""><code>connections = ((core_count * 2) + effective_spindle_count)</code></pre><p>For example, you server has 4 Core i7 CPU and 1 hard disk should a connection pool of: 9 = ((4 * 2) + 1). Call it 10 as a nice round number. </p><p>For high transaction applications, horizontal scale with multiple GraphQL Engine clusters is best practices. However, you should aware of total connections of all nodes. The number must be lower than max connections of Postgres</p><h4 id="HASURA_GRAPHQL_CONNECTIONS_PER_READ_REPLICA">HASURA GRAPHQL CONNECTIONS PER READ REPLICA</h4><ul><li>Environment variable: <code>HASURA_GRAPHQL_CONNECTIONS_PER_READ_REPLICA</code></li></ul><p>With Read-replica, Hasura can load balancing multiple databases. However, you will need to balance connection between database nodes too:</p><ul><li>Master connections (<code>HASURA_GRAPHQL_PG_CONNECTIONS</code>) now are used for write only. You can decrease max connections lower if Hasura doesn&#39;t write much, or share connections with another Hasura nodes.</li><li>Currently read-replica connections use one setting for all databases. It can&#39;t flexibly configure specific value for each node. Therefore you need to aware of total connections when scaling Hasura to multiple nodes. </li></ul><h4 id="HASURA_GRAPHQL_LIVE_QUERIES_MULTIPLEXED_REFETCH_INTERVAL">HASURA GRAPHQL LIVE QUERIES MULTIPLEXED REFETCH INTERVAL</h4><ul><li>Environment variable: <code>HASURA_GRAPHQL_LIVE_QUERIES_MULTIPLEXED_REFETCH_INTERVAL</code></li></ul><p>*(Can skip it if you don&#39;t use subscription)*</p><p>Default: 1000 (1 second)</p><p>In brief, live query subscribers are grouped with same query and variables. GraphQL Engine just need to execute one query and return same results to clients once every refetch interval. </p><p>The smaller interval is, the faster update clients receive. However, everything has a cost. Small interval with large number of subscriptions need high CPU and memory resources. If you don&#39;t really need too realtime, the interval can be set longer a bit. In contrast, with small-medium number of subscriptions, default value (1 second) is good enough </p><h4 id="HASURA_GRAPHQL_LIVE_QUERIES_MULTIPLEXED_BATCH_SIZE">HASURA GRAPHQL LIVE QUERIES MULTIPLEXED BATCH SIZE</h4><ul><li>Environment variable: <code>HASURA_GRAPHQL_LIVE_QUERIES_MULTIPLEXED_BATCH_SIZE</code></li></ul><p>*(Can skip it if you don&#39;t use subscription)*</p><p>Default: 100</p><p>Imagine there are 1,000,000 subscribers that subscribe same query. Emit to million of websockets in sequence can cause delay and eat more memory in long queue. However, small batch size can increase number of SQL transactions. This value needs to keep balance. If you don&#39;t have idea to determine what value, just use default value </p><h3 id="Scale_Hasura_">Scale Hasura </h3><p>Hasura GraphQL Engine binary is containerized by default, so it is easy to scale horizontally. You need to estimate concurrent requests&#x2F;second, benchmark how many requests 1 Hasura node can load, then scale multiple nodes with simple calculation:</p><pre class="code" data-lang=""><code>total_nodes = required_ccu &#x2F; requests_per_node + backup_node</code></pre><p><code>backup_node</code> is <code>0</code> or <code>1</code>, depending on your plan</p><p>However, you need to aware of total Postgres connections. Default <code>HASURA_GRAPHQL_PG_CONNECTIONS</code> value is <code>50</code>, meanwhile default Postgres <code>max_connections</code> configuration is <code>100</code>. Postgres server will easily be out of connections with <code>3</code> Hasura nodes, or <code>2</code> nodes with events&#x2F;action services that connect directly to the database. </p><pre class="code" data-lang=""><code>pg_max_connections &gt;= hasura_nodes * hasura_pg_connections + event_nodes * event_pg_connections</code></pre><h3 id="Scale_PostgreSQL_Servers">Scale PostgreSQL Servers</h3><p>Hasura GraphQL Engine is a query engine that utilize power of database, so performance of Postgres directly affects Hasura performance. However, it isn&#39;t easy to do if you don&#39;t have much Database Admin knowledge. Moreover, there are many Postgres extensions and scaling tools. you don&#39;t have idea what tool to use, and does it work well with Hasura.</p><p>I did some experiment to test and compare popular tools <a href="https://github.com/hgiasac/hasura-postgres-at-scale">here</a>, and can give you some opinion tips:</p><ul><li>Easiest way is using Cloud SQL Services (GCP, AWS, Azure...). Cloud Providers can ensure high availability with extra cost. <a href="https://hasura.io/hasura-pro/">Hasura Pro</a> supports load balancing with Read-replica, utilize master-standby databases&#39;s performance easily with one line of config. You can also use <a href="https://www.pgbouncer.org/">PgBouncer</a> proxy over Postgres databases if require too many connections.</li><li>In contrast, high availability is critical on-premise servers. However, with the help or Docker Swarm&#x2F;Kubernetes, deployment work is easier. IMO, you can easily deploy high availability and load balancing Hasura stack with <code>repmgr</code> and <code>Hasura Pro</code>. However, it is safer if you use 1 master + 2 standby cluster.</li><li>If you don&#39;t like Hasura Pro, you can use another load balancer such as <a href="https://www.pgpool.net/mediawiki/index.php/Main_Page">PgPool II</a> or <a href="https://www.percona.com/blog/2018/10/02/scaling-postgresql-using-connection-poolers-and-load-balancers-for-an-enterprise-grade-environment/">HAProxy + PGBouncer</a> stack. However, it takes extra works to setup, and has more server cost. IMO, extra server cost won&#39;t be cheaper than Hasura Pro.</li></ul><p>You can read more detail about Postgres at scale <a href="https://github.com/hgiasac/hasura-postgres-at-scale">here</a></p><h3 id="Monitoring">Monitoring</h3><p>Monitor tools help us track and alert error issue, performance and hardware usage. It is very critical on production. There are many open source and commercial services. However, sometimes you have to combine many tools because of architecture complexity.</p><h4 id="Hasura_">Hasura </h4><p>Hasura logging is well structure, in JSON format. It is easy to integrate with Log analytics and monitor services such as <a href="https://www.datadoghq.com/">Datadog</a>, <a href="https://cloud.google.com/logging">Google Cloud Logging</a>, <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/WhatIsCloudWatchLogs.html">Amazon CloudWatch Logs</a> through Docker&#x2F;Kubernetes logging drivers.</p><p>Hasura Pro also provides Metrics monitor that analyzes operations, errors and performance with friendly interface</p><p><img src="/assets/hasura-usage.png" alt="Hasura usage"/></p><h4 id="Server__Postgres">Server + Postgres</h4><ul><li>If you use cloud services (GCP, AWS, Azure...), they provider built-in metrics of server usage (CPU, RAM, network...). </li><li>On premise servers, we can use open source docker services such as <a href="https://github.com/google/cadvisor">cAdvisor</a>, or commercial services such as <a href="https://okmeter.io/">okMeter</a></li><li>With Postgres, we can use <a href="https://github.com/CrunchyData/pgmonitor">pgMonitor</a>, <a href="https://github.com/cybertec-postgresql/pgwatch2">pgwatch2</a> or commercial <a href="https://okmeter.io/">okMeter</a></li></ul><h2 id="Software_Architecture_and_Best_Practices">Software Architecture and Best Practices</h2><h3 id="Hasura_as_Data_service_">Hasura as Data service </h3><h4 id="Connection_Pooler">Connection Pooler</h4><p>Database connection management isn&#39;t easy task, especially when scaling to multiple application nodes. There are common issues such as connection leaking, maximum connections exceeded. If you use serverless applications for actions&#x2F;event trigger that connect directly to database, connection leaking is unavoidable, because every invocation may result in a new connection to the database, especially when the number of services are grown to hundreds.</p><p>We can use many solution such as PgBouncer, vertical scaling and increase <code>max_connections</code> on Postgres configurations. However, increasing too many connections can backstab your server, affect performance.</p><p>Therefore, we can reduce connection usage by querying data from GraphQL Engine instead. Connection polling will be centralized in Hasura nodes.</p><p><img src="/assets/hasura-connection-poller.png" alt="hasura connection pooling"/></p><p>You can read more in <a href="https://hasura.io/blog/level-up-your-serverless-game-with-a-graphql-data-as-a-service-layer/">Hasura Blog</a></p><h4 id="Load_Balancer_Pro">Load Balancer (Pro)</h4><p>Read replica on Hasura Pro can load balancing master and standby nodes. Therefore it can be easy-to-use alternative of PgPool or HAProxy.</p><p><img src="/assets/hasura-load-balancer.png" alt="hasura load-balancer"/></p><h3 id="Understand_your_data">Understand your data</h3><p>Hasura&#39;s query performance relies on Database performance. When there is any performance issue, you need profiling to check bottleneck point, and optimize your database queries. Utilize power of Postgres can help boosting application speed.</p><p>Fundamental knowledge you should know and practice:</p><ul><li>Index your table</li><li>Optimize queries with view, materialized view, and functions</li><li>Use trigger to update data instead of using 2 or more request calls</li><li>Normalize data structure</li><li>EXPLAIN, ANALYZE</li></ul><h3 id="Microservices">Microservices</h3><p>Hardware has its limit. You have to throw much money to scale servers as well as data optimization. Moreover, Postgres doesn&#39;t support master-master replica, so it will be bottleneck if we store all data in one database. Therefore, you can divide you business logic to multiple smaller services, or microservices.</p><p>Hasura encourages microservices with Remote Schema. It can take responsibility as an API Gateway that route to multiple smaller GraphQL servers.</p><p><img src="/assets/hasura-microservices.png" alt="hasura load-balancer"/></p><p>For example, for an e-commerce application, you can design 3 Hasura services:</p><ul><li>User + Authentication</li><li>Product management</li><li>Order + Transactions</li></ul><p>The design philosophy is flexible depending on project scope. On small size project, one database can be good enough. The downside is remote schemas can&#39;t join data to each other. However, it will be gone after <a href="https://github.com/hasura/graphql-engine/pull/2392">remote-join PR</a> are merged</p><h3 id="Postgres_ecosystem">Postgres ecosystem</h3><p>Thank to open source community, Postgres has many extensions for various type of applications:</p><ul><li>Time-series data, metrics, IoT: <a href="https://www.timescale.com/">TimescaleDB</a>, <a href="https://www.citusdata.com/">CitusDB</a></li><li>Spatial and geographic objects: <a href="https://postgis.net/">PostGIS</a></li><li>Image processing: <a href="https://github.com/drotiro/postpic">PostPic</a> </li></ul><p>With remote schema, we can use Hasura with multiple databases for various use cases, for example, Postgres for user data, TimescaleDB for transaction logs, and Postgis for Geographic service.</p><h2 id="Summary_">Summary </h2><p>Optimization and scaling are complicated work that require the combination of server architecture and software design. We have to keep monitoring, profiling, and refactoring step by step. Postgres is single point of failure. GraphQL Engine is on application level, and it can&#39;t automatically optimize database for us. </p><p>Hope this guide can help you using Hasura better at scale.</p></article></div></div></div></section><footer><div class="wrapper"><div class="container grid-lg"><hr/><div class="text-center"><a class="secondary" href="https://github.com/hgiasac"><i class="fa fa-github fa-2x"> </i></a><a class="secondary" href="https://www.linkedin.com/in/toan-nguyen-83295527/"><i class="fa fa-linkedin fa-2x"> </i></a><a class="secondary" href="https://stackoverflow.com/users/4230985/hgiasac"><i class="fa fa-stack-overflow fa-2x"> </i></a></div><div class="text-center mt-2">© Toan Nguyen 2017-2020</div></div></div></footer></body></html>