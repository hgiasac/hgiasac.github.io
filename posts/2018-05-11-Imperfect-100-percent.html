<html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Imperfect 100 percent (2018-05-11)</title><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto"/><link rel="stylesheet" href="/assets/main.min.css"/><link rel="stylesheet" href="https://maxcdn.icons8.com/fonts/line-awesome/1.1/css/line-awesome-font-awesome.min.css"/></head><meta name="description" content="In real world, deal with float-point number isn&#39;t easy as we think. Fixed-point number can be very very long that human&#39;s eyes can&#39;t read. Some programming languages such as JavaScript that don&#39;t support big numbers, the only solution is converting to string..."/><body><header><div class="container grid-lg"><nav class="horizontal main-nav"><ul><li><a href="/">Home</a></li><li><a href="/works.html">Works</a></li><li><a href="/posts">Posts</a></li><li><a href="/about.html">About</a></li><li><a href="https://www.visualcv.com/toan-nguyen">CV</a></li></ul></nav></div></header><section class="section"><div id="main"><div class="wrapper"><div class="container grid-lg"><hr class="mt-2"/><article class="article"><h1 id="Imperfect_100_percent">Imperfect 100 percent</h1><h2 id="Issue_with_round">Issue with round</h2><p>In real world, deal with float-point number isn&#39;t easy as we think. Fixed-point number can be very very long that human&#39;s eyes can&#39;t read. Some programming languages such as JavaScript that don&#39;t support big numbers, the only solution is converting to string. This is the common case if you work with Databases.</p><p>To make float-point number read and compute, the most simple choice is rounding it. Most of problems was solved until we need to calculate percent statistics. Normally, it is solved easily with simple steps: sum, divide, and round:</p><pre class="code" data-lang="haskell"><code>calculatePercent :: List Double -&gt; List Double <br/>calculatePercent xs = map (\x -&gt; round&#39; $ x &#x2F; total) xs<br/>  where<br/>    total = sum xs<br/>    round&#39; n = (round (x * 10000.0)) &#x2F; 100.0 -- &#x2F;&#x2F; round to 2 fixed point numbers</code></pre><p>It seems okay. Round number also causes accuracy lost. The sum of percent values aren&#39;t always exact <code>100</code>, the result range can be from <code>99</code> to <code>101</code>, called <a href="https://en.wikipedia.org/wiki/Round-off_error">Round-off Error</a></p><pre class="code" data-lang=""><code>[3, 3, 3]<br/><br/>33.33 + 33.33 + 33.33 = 99.99</code></pre><h2 id="Work_Around">Work Around</h2><p>According to <a href="https://stackoverflow.com/questions/13483430/how-to-make-rounded-percentages-add-up-to-100">Stack Overflow Question</a>, there are several way to work around this issue. In brief, we&#39;ll round each candidate until the sum is 100. Candidates are determined by largest value, or minimum rounding error </p><pre class="code" data-lang="haskell"><code>import Data.List (sort, sortBy, drop, take)<br/>import GHC.Exts (sortWith)<br/><br/>betterPercent :: [Double] -&gt; [Double] <br/>betterPercent xs = map ((\x -&gt; x &#x2F; 100.0) . snd) $ sortWith fst newTValues<br/>  where<br/>    total = sum xs<br/>    scaleFactor = 10000.0<br/>    <br/>    floor&#39; :: Double -&gt; Double<br/>    floor&#39; n = fromIntegral $ floor (n * scaleFactor)<br/>    <br/>    flooredValues :: [Double]<br/>    flooredValues = map (\x -&gt; floor&#39; $ x &#x2F; total) xs<br/>    <br/>    needToRound :: Int<br/>    needToRound = fromIntegral $ floor $ scaleFactor - (sum flooredValues)<br/>    <br/>    tupledValues = reverse $ sortWith snd $ zip [1..] flooredValues<br/>    <br/>    newTValues :: [(Int, Double)]<br/>    newTValues = (map (\(i, x) -&gt; (i, x + 1.0)) $ take needToRound tupledValues) &lt;&gt; drop needToRound tupledValues<br/></code></pre><pre class="code" data-lang=""><code>[3, 3, 3]<br/>33.33 + 33.33 + 33.34 = 100</code></pre><p>Hooray, the sum is <code>100</code> now! However, member values is still inaccurate. Everyone will ask:</p><blockquote><p>Why 33.34 = 33.33?</p></blockquote><p>We can&#39;t be sure how to explain this. Explain by mathematic knowledge, or just: because it is real number</p><blockquote><p>I also do a simple library written in PureScript <a href="https://github.com/hgiasac/purescript-round-ratio">Round Ratio</a></p></blockquote><h2 id="Rational_Number">Rational Number</h2><p>The most accuracy solution is using Fraction number. In mathematic, the form of fraction number is 1&#x2F;2. In Haskell, there is <code>Rational</code> type:</p><pre class="code" data-lang="haskell"><code>n :: Rational<br/>n = 1 % 2</code></pre><p>We just keep the original form with numerator and denominator and use them to compute when necessary. However, the performance is slower than float-point number. When print the value, we also need to convert to fixed-point value for easier understanding. We can&#39;t ask the user recalculate fraction values over and over again.</p><p>Sometimes we have to choose between accuracy and performance...</p><h2 id="References">References</h2><ol><li><a href="https://stackoverflow.com/questions/13483430/how-to-make-rounded-percentages-add-up-to-100">How to make rounded percentages add up to 100%</a></li></ol></article></div></div></div></section><footer><div class="wrapper"><div class="container grid-lg"><hr/><div class="text-center"><a class="secondary" href="https://github.com/hgiasac"><i class="fa fa-github fa-2x"> </i></a><a class="secondary" href="https://www.linkedin.com/in/toan-nguyen-83295527/"><i class="fa fa-linkedin fa-2x"> </i></a><a class="secondary" href="https://stackoverflow.com/users/4230985/hgiasac"><i class="fa fa-stack-overflow fa-2x"> </i></a></div><div class="text-center mt-2">Â© Toan Nguyen 2017-2019</div></div></div></footer></body></html>